<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Linux 内核网络中的 sk_buff 数据结构 - 浮枕星海</title><link rel="manifest" href="/manifest.json"><meta name="theme-color" content="#9932CC"><meta name="application-name" content="浮枕星海"><meta name="msapplication-TileImage" content="/img/favicon.png"><meta name="msapplication-TileColor" content="#9932CC"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="浮枕星海"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="本文转载自 houmin.cc，原文已被删除，但因为之前阅读此文感觉说明较为清楚（后来查了下主要参考的是 Understanding Linux Network Internals 这本书），因此为方便今后查看，从 wayback machine 找到并转载了这篇文章。文章内容可能有补充修正。 在 Linux 内核的网络代码中，sk_buff 或许是最重要的数据结构，用来表示已接收或将要传输的数据"><meta property="og:type" content="blog"><meta property="og:title" content="Linux 内核网络中的 sk_buff 数据结构"><meta property="og:url" content="https://universesaurora.top/2023/04/21/skbuff-repost/"><meta property="og:site_name" content="浮枕星海"><meta property="og:description" content="本文转载自 houmin.cc，原文已被删除，但因为之前阅读此文感觉说明较为清楚（后来查了下主要参考的是 Understanding Linux Network Internals 这本书），因此为方便今后查看，从 wayback machine 找到并转载了这篇文章。文章内容可能有补充修正。 在 Linux 内核的网络代码中，sk_buff 或许是最重要的数据结构，用来表示已接收或将要传输的数据"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.pixabay.com/photo/2018/10/19/12/14/train-3758523_1280.jpg"><meta property="article:published_time" content="2023-04-21T02:22:53.000Z"><meta property="article:modified_time" content="2023-04-21T08:03:10.000Z"><meta property="article:author" content="浮枕"><meta property="article:tag" content="内核"><meta property="article:tag" content="Linux"><meta property="article:tag" content="网络"><meta property="article:tag" content="sk_buff"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://cdn.pixabay.com/photo/2018/10/19/12/14/train-3758523_1280.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://universesaurora.top/2023/04/21/skbuff-repost/"},"headline":"Linux 内核网络中的 sk_buff 数据结构","image":["https://cdn.pixabay.com/photo/2018/10/19/12/14/train-3758523_1280.jpg"],"datePublished":"2023-04-21T02:22:53.000Z","dateModified":"2023-04-21T08:03:10.000Z","author":{"@type":"Person","name":"浮枕"},"publisher":{"@type":"Organization","name":"浮枕星海","logo":{"@type":"ImageObject","url":"https://universesaurora.top/img/logo.png"}},"description":"本文转载自 houmin.cc，原文已被删除，但因为之前阅读此文感觉说明较为清楚（后来查了下主要参考的是 Understanding Linux Network Internals 这本书），因此为方便今后查看，从 wayback machine 找到并转载了这篇文章。文章内容可能有补充修正。 在 Linux 内核的网络代码中，sk_buff 或许是最重要的数据结构，用来表示已接收或将要传输的数据"}</script><link rel="canonical" href="https://universesaurora.top/2023/04/21/skbuff-repost/"><link rel="alternate" href="/atom.xml" title="浮枕星海" type="application/atom+xml"><link rel="icon" href="/img/favicon.png"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/6.0.0/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/xcode.min.css"><link rel="stylesheet" href="https://fonts.lug.ustc.edu.cn/css2?family=Source+Serif+Pro&amp;family=Roboto+Mono&amp;family=Noto+Serif+SC"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.10.0/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.8.1/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=UA-172917863-2" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'UA-172917863-2');</script><!--!--><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.css"><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdnjs.loli.net/ajax/libs/pace/1.2.4/pace.min.js"></script><!--!--><!--!--><meta name="follow.it-verification-code" content="6w6wNNa9dLg34hkzxXZS"><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.png" alt="浮枕星海" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/links">友链</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="fill" src="https://cdn.pixabay.com/photo/2018/10/19/12/14/train-3758523_1280.jpg" alt="Linux 内核网络中的 sk_buff 数据结构"></span></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-04-21T02:22:53.000Z" title="4/21/2023, 2:22:53 AM">2023-04-21</time>发表</span><span class="level-item"><time dateTime="2023-04-21T08:03:10.000Z" title="4/21/2023, 8:03:10 AM">2023-04-21</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E5%86%85%E6%A0%B8/">内核</a></span><span class="level-item">1 小时读完 (大约6888个字)</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><h1 class="title is-3 is-size-4-mobile">Linux 内核网络中的 sk_buff 数据结构</h1><div class="content"><p>本文转载自 <a target="_blank" rel="noopener" href="https://houmin.cc/">houmin.cc</a>，原文已被删除，但因为之前阅读此文感觉说明较为清楚（后来查了下主要参考的是 Understanding Linux Network Internals 这本书），因此为方便今后查看，从 <a target="_blank" rel="noopener" href="https://web.archive.org/web/20220529013919/https://houmin.cc/posts/bec07334/">wayback machine</a> 找到并转载了这篇文章。文章内容可能有补充修正。</p>
<p>在 Linux 内核的网络代码中，<code>sk_buff</code> 或许是最重要的数据结构，用来表示已接收或将要传输的数据。 <code>sk_buff</code> 定义在 <code>include/linux/skbuff.h</code> 中，它由许多变量组成，目标就是满足所有网络协议的需要。随着数据包在内核协议栈不同层次传递时，Linux 内核不是通过层与层之间的数据拷贝，而是通过追加头信息的方式，这即是 <code>sk_buff</code> 被使用的典型场景：在不同网络协议层之间移动，通过添加数据头的形式传递数据。本文分析采用的是 2.6.35 版本内核。</p>
<span id="more"></span>
<p>随着内核的迭代，<code>sk_buff</code> 的结构已经被添加了许多新的选项，已经存在的字段也被重新整理了很多遍。可将内部的字段分为以下几类：</p>
<ul>
<li>Layout 负责内存布局的字段</li>
<li>General 通用的字段</li>
<li>Feature-specific 对应特别功能字段</li>
<li>Management functions 一些用来管理 sk_buff 的函数</li>
</ul>
<p><code>sk_buff</code> 在不同的网络层次被使用（MAC 或其他在 L2 的协议，在 L3 的 IP 协议，在 L4 的 TCP 或 UDP 等），当它从一层传递到另一层时，各个字段也会发生变化。在被传递到 L3 之前，L4 会追加头信息，然后在被传递到 L2 之前，L3 会追加头信息。<strong>从一层传递到另一层时，通过追加头信息的方式比将数据在层之间拷贝会更有效率</strong>。由于要在 buff 的开头增加空间（与平时常见的在尾部追加空间相比）是一项复杂的操作，内核便提供了 <code>skb_reserve</code> 函数执行这个操作。因此，随着 buffer 从上层到下层的传递，每层协议做的第一件事就是调用 <code>skb_reserve</code> 去为它们的协议头在 buffer 的头部分配空间。在后面，我们将通过一个例子去了解内核如何在当 buffer 在各个层间传递时，确保为每一层保留了足够的空间让它们添加它们自己的协议头。</p>
<p>在接收数据时，buffer 会被从下层到上层传递，在从下到上的过程中，前一层的协议头对于当前层来说已经没有用了。比如：L2 的协议头只会被处理 L2 协议的设备驱动程序使用，L3 并不关心 L2 的头。那么内核怎么做的呢? 内核的实现是： <strong><code>sk_buff</code> 中有一个指针会指向当前位于的层次的协议的协议头的内存开始地址，于是从 L2 到 L3 时，只需将指向 L2 头部的指针移动到 L3 的头部即可</strong>（又是一步追求效率的操作）。</p>
<h1 id="layout-fields" tabindex="-1">Layout Fields</h1>
<p>Linux 内核把系统中所有的 <code>sk_buff</code> 实例维护在一个双向链表中。和任何双向链表类似，<code>sk_buff</code> 链表的每个节点也通过 <code>next</code> 和 <code>prev</code> 分别指向后继和前驱节点。但是 <code>sk_buff</code> 链表还要求：每个节点必须能够<strong>很快的</strong>找到整个链表的头节点。为了实现这个要求，一个额外的数据结构 <code>sk_buff_head</code> 被添加到链表的头部，作为一个空节点：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff_head</span> &#123;</span></span><br><span class="line">	<span class="comment">/* These two members must be first. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span>	*<span class="title">next</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span>	*<span class="title">prev</span>;</span></span><br><span class="line"></span><br><span class="line">	__u32		qlen;      <span class="comment">// 表示链表中的节点数，当前的sk_buff链上包含多少个skb</span></span><br><span class="line">	<span class="type">spinlock_t</span>	lock;  <span class="comment">// 加锁，防止对表的并发访问</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>sk_buff</code> 和 <code>sk_buff_head</code> 开始的两个字段是相同的，都是 <code>next</code> 和 <code>prev</code> 指针。即使 <code>sk_buff_head</code> 比 <code>sk_buff</code> 更轻量化，也允许这两种结构在链表中共存。另外，可以使用相同函数来操作 <code>sk_buff</code> 和 <code>sk_buff_head</code>。</p>
<p>为了实现通过每个节点都能快速找到链表头，每个节点都会包含一个指向链表中唯一的 <code>sk_buff_head</code> 的指针（<code>list</code>）。</p>
<p><img src="https://s2.loli.net/2023/04/21/zHdEn3NG4hPFiRk.jpg" alt="List of sk_buff elements"></p>
<p>下面是 layout 字段的详细解释：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> &#123;</span></span><br><span class="line">	<span class="comment">/* These two members must be first. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span>		*<span class="title">next</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span>		*<span class="title">prev</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sock</span>		*<span class="title">sk</span>;</span>       <span class="comment">// 表示从属于那个socket，主要是被4层用到。  </span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		len,  <span class="comment">// 表示在 buffer 中数据区域的大小, 值会随着 buffer 在各层间传递而改变</span></span><br><span class="line">				data_len;       <span class="comment">// 和 len 不同的是，data_len 只记录分段中的数据大小</span></span><br><span class="line">	__u16			mac_len,    <span class="comment">// MAC 头部的长度</span></span><br><span class="line">				hdr_len;        <span class="comment">// header len</span></span><br><span class="line"></span><br><span class="line">	<span class="type">void</span>			(*destructor)(<span class="keyword">struct</span> sk_buff *skb);  <span class="comment">// skb的析构函数，一般都是设置为sock_rfree或者sock_wfree</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* ... */</span></span><br><span class="line">  </span><br><span class="line">	<span class="comment">/* These elements must be at the end, see alloc_skb() for details.  */</span></span><br><span class="line">	<span class="type">sk_buff_data_t</span>		tail;</span><br><span class="line">	<span class="type">sk_buff_data_t</span>		end;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span>		*head,</span><br><span class="line">				*data;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		truesize; <span class="comment">// 表示整个skb的大小, 包括skb本身以及数据, 也就是 len+sizeof(struct sk_buff) </span></span><br><span class="line">	<span class="type">atomic_t</span>		users;  <span class="comment">// sk_buff 的引用计数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>head</code> 、<code>end</code> 、<code>data</code> 和 <code>tail</code> 这 4个指针用来表示 buffer 中数据域的边界。当每一层为了任务而准备 buffer 时，为了协议头或数据，可能会分配更多的空间。 <code>head</code> 和 <code>end</code> 指向了 buffer 被分配的内存区域的开始和结束， <code>data</code> 和 <code>tail</code> 指向真实数据的开始和结束。</p>
<p><img src="https://s2.loli.net/2023/04/21/NAYkqDIVCwS3cFW.png" alt="head/end versus data/tail pointers"></p>
<p>每一层能够在 <code>head</code> 和 <code>data</code> 之间的区域填充协议头，或者在 <code>tail</code> 和 <code>end</code> 之间的区域填充新的数据。</p>
<h1 id="general-fields" tabindex="-1">General Fields</h1>
<p>在 <code>sk_buff</code> 中存在一些通用目的的字段，这些字段没有与特定的内核功能绑定：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> &#123;</span></span><br><span class="line">	<span class="comment">/* ... */</span></span><br><span class="line"> </span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">skb_timeval</span>	<span class="title">tstamp</span>;</span>  <span class="comment">// 时间戳，表示何时被接收或有时表示包预定的传输时间</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net_device</span>	*<span class="title">dev</span>;</span>      <span class="comment">// 描述一个网络设备，之后会专门分析</span></span><br><span class="line"></span><br><span class="line">	<span class="type">sk_buff_data_t</span>		transport_header;  <span class="comment">// L4 协议栈的协议头</span></span><br><span class="line">	<span class="type">sk_buff_data_t</span>		network_header;    <span class="comment">// L3 协议栈的协议头</span></span><br><span class="line">	<span class="type">sk_buff_data_t</span>		mac_header;        <span class="comment">// L2 协议栈的协议头</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span>  <span class="title">dst_entry</span>	*<span class="title">dst</span>;</span>  <span class="comment">// 由路由子系统使用，据说数据结构比较复杂</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * This is the control buffer. It is free to use for every</span></span><br><span class="line"><span class="comment">	 * layer. Please put your private variables there. If you</span></span><br><span class="line"><span class="comment">	 * want to keep them across layers you have to do a skb_clone()</span></span><br><span class="line"><span class="comment">	 * first. This is owned by whoever has the skb queued ATM.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">char</span>			cb[<span class="number">48</span>];  <span class="comment">// control buffer, 后面详细分析</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 校验相关</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		__wsum		csum;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			__u16	csum_start;</span><br><span class="line">			__u16	csum_offset;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;;</span><br><span class="line">	__u32			priority;  <span class="comment">// 优先级，主要用于QoS</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 一些标识位</span></span><br><span class="line">	kmemcheck_bitfield_begin(flags1);</span><br><span class="line">	__u8			local_df:<span class="number">1</span>,  <span class="comment">// 是否可以本地切片的标志</span></span><br><span class="line">				cloned:<span class="number">1</span>,     <span class="comment">// 设置后表示此结构是另一个sk_buff缓冲区的克隆</span></span><br><span class="line">				ip_summed:<span class="number">2</span>,  <span class="comment">// 这个表示校验相关的一个标记,表示硬件驱动是否为我们已经进行了校验</span></span><br><span class="line">				nohdr:<span class="number">1</span>,      <span class="comment">// 这个域如果为1,则说明这个skb的头域指针已经分配完毕，因此这个时候计算头的长度只需要head和data的差就可以了</span></span><br><span class="line">				nfctinfo:<span class="number">3</span>;</span><br><span class="line">	__u8			pkt_type:<span class="number">3</span>,  <span class="comment">// 主要是表示数据包的类型，比如多播，单播，回环等等，可在 include/linux/if_packet.h 中查看</span></span><br><span class="line">				fclone:<span class="number">2</span>,        <span class="comment">// 这个域是一个clone标记，主要是在fast clone中被设置</span></span><br><span class="line">				ipvs_property:<span class="number">1</span>, <span class="comment">// ipvs 相关</span></span><br><span class="line">				peeked:<span class="number">1</span>,        <span class="comment">// udp 相关，表示只是查看数据</span></span><br><span class="line">				nf_trace:<span class="number">1</span>;      <span class="comment">// netfilter 相关</span></span><br><span class="line">	kmemcheck_bitfield_end(flags1);</span><br><span class="line">  </span><br><span class="line">	__be16			protocol;  <span class="comment">// 从 L2 处的网卡设备驱动程序的角度来看，在更高层次上使用的协议，完整列表可在 include/linux/if_ether.h</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* ... */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>transport_header</code>、<code>network_header</code> 和 <code>mac_header</code> 分别为 L4 、L3 和 L2 的协议头。和之前版本比较有了变化，不再是联合体，使用更加方便了，Linux给出了很方便的函数直接定位到各层的头部。下图是2.4版本的，只是说明了数据包在不同协议层移动时 <code>data</code> 指针的处理。</p>
<ul>
<li>当接收到数据包时，负责处理第 n 层协议头的函数从第 n-1 层接收一个 buffer，其中<code>skb-&gt;data</code> 指向第 n 层协议头的开头。</li>
<li>处理第 n 层的函数会为此层初始化适当的指针（例如，L3 的处理函数会为 <code>skb-&gt;nh</code> 赋值）以保留 <code>skb-&gt;data</code> 字段，因为当 <code>skb-&gt;data</code> 被赋值为 buffer 内的其他偏移量时，该指针的内容将在下一层的处理过程中丢失。</li>
<li>该函数完成第 n 层的处理，并在将数据包传递到第 n+1 层处理程序之前，更新 <code>skb-&gt;data</code> 使其指向第 n 层协议头的末尾（即第 n+1 层协议头的开始位置）</li>
</ul>
<p><img src="https://s2.loli.net/2023/04/21/lWCyjnVxNgf5RIA.png" alt="Header's pointer initializations while moving from layer two to layer three"></p>
<p>下面说一下 control buffer ，它用来存储一些私有信息，由各层维护以供内部使用。它是在 <code>sk_buff</code> 结构中静态分配的（当前大小为40个字节），并且足够大以容纳每一层所需的任何私有数据。在每一层的代码中，访问都是通过宏进行的，以使代码更具可读性。例如，TCP使用该空间存储 <code>tcp_skb_cb</code> 数据结构，该数据结构在 <code>include/net/tcp.h</code> 中定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcp_skb_cb</span> &#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">	__u32		seq;		<span class="comment">/* Starting sequence number	*/</span></span><br><span class="line">	__u32		end_seq;	<span class="comment">/* SEQ + FIN + SYN + datalen	*/</span></span><br><span class="line">	__u8		tcp_flags;	<span class="comment">/* TCP header flags. (tcp[13])	*/</span></span><br><span class="line">	__u32		ack_seq;	<span class="comment">/* Sequence number ACK&#x27;d	*/</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这是 TCP 代码访问结构的宏，宏仅由一个指针转换组成：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TCP_SKB_CB(__skb)	((struct tcp_skb_cb *)&amp;((__skb)-&gt;cb[0]))</span></span><br></pre></td></tr></table></figure>
<p>这是一个示例，其中 TCP 模块在收到分段后填写 <code>cb</code> 结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">tcp_v4_fill_cb</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb, <span class="type">const</span> <span class="keyword">struct</span> iphdr *iph, <span class="type">const</span> <span class="keyword">struct</span> tcphdr *th)</span> &#123;</span><br><span class="line">    TCP_SKB_CB(skb)-&gt;seq = ntohl(th-&gt;seq);</span><br><span class="line">    TCP_SKB_CB(skb)-&gt;end_seq = (TCP_SKB_CB(skb)-&gt;seq + th-&gt;syn + th-&gt;fin + skb-&gt;len - th-&gt;doff * <span class="number">4</span>);</span><br><span class="line">    TCP_SKB_CB(skb)-&gt;ack_seq = ntohl(th-&gt;ack_seq);</span><br><span class="line">    TCP_SKB_CB(skb)-&gt;tcp_flags = tcp_flag_byte(th);</span><br><span class="line">    TCP_SKB_CB(skb)-&gt;tcp_tw_isn = <span class="number">0</span>;</span><br><span class="line">    TCP_SKB_CB(skb)-&gt;ip_dsfield = ipv4_get_dsfield(iph);</span><br><span class="line">    TCP_SKB_CB(skb)-&gt;sacked  = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="feature-specific-fields" tabindex="-1">Feature-Specific Fields</h1>
<p>Linux内核是模块化的，允许你选择要包括的内容和要忽略的内容。因此，只有在编译内核时开启支持像 Netfilter 或 QoS 之类的特定功能的情况下，某些字段才会包含在 <code>sk_buff</code> 数据结构中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> &#123;</span></span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_NF_CONNTRACK) || defined(CONFIG_NF_CONNTRACK_MODULE)</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nf_conntrack</span>	*<span class="title">nfct</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span>		*<span class="title">nfct_reasm</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_BRIDGE_NETFILTER</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nf_bridge_info</span>	*<span class="title">nf_bridge</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_NET_SCHED</span></span><br><span class="line">	__u16			tc_index;	<span class="comment">/* traffic control index */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_NET_CLS_ACT</span></span><br><span class="line">	__u16			tc_verd;	<span class="comment">/* traffic control verdict */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="management-functions" tabindex="-1">Management Functions</h1>
<p>内核提供了许多很简短的简单函数来操纵 <code>sk_buff</code> 节点或链表。如果查看文件 <code>include/linux/skbuff.h</code> 和 <code>net/core/skbuff.c</code>，你会发现几乎所有功能都有两个版本，名称分别为 <code>do_something</code> 和 <code>__do_something</code>。通常，第一个是包装函数，它在对第二个调用的周围添加了额外的健全性检查或锁定机制。内部 <code>__do_something</code> 函数通常不直接调用。该规则的例外通常是编码不良的函数，这些函数最终将被修复。</p>
<h2 id="%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D" tabindex="-1" id="内存分配">内存分配</h2>
<h3 id="alloc_skb" tabindex="-1" id="alloc-skb">alloc_skb</h3>
<p><code>alloc_skb</code> 是分配缓冲区的主要函数，在 <code>net/core/skbuff.c</code> 中定义。</p>
<p><code>__alloc_skb</code> 分配缓冲区和一个 <code>sk_buff</code> 结构，这个函数起始可以看作三部分：</p>
<ul>
<li>第一部分是分配内存，由于数据缓冲区和 <code>sk_buff</code> 自身是两个不同的结构，所以创建单个缓冲区涉及两个内存分配
<ul>
<li>调用函数 <code>kmem_cache_alloc</code> 从缓存中获取 <code>sk_buff</code> 数据结构</li>
<li>调用 <code>kmalloc</code> 获取数据缓冲区，而 <code>kmalloc</code> 也会使用缓存的内存（如果可用）</li>
</ul>
</li>
<li>第二部分是初始化分配的 skb 的相关域</li>
<li>第三部分是处理 <code>fclone</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *__<span class="title">alloc_skb</span>(<span class="title">unsigned</span> <span class="title">int</span> <span class="title">size</span>, <span class="title">gfp_t</span> <span class="title">gfp_mask</span>, <span class="title">int</span> <span class="title">fclone</span>, <span class="title">int</span> <span class="title">node</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">cache</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">skb_shared_info</span> *<span class="title">shinfo</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>;</span></span><br><span class="line">	u8 *data;</span><br><span class="line"></span><br><span class="line">	cache = fclone ? skbuff_fclone_cache : skbuff_head_cache;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Get the HEAD */</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 申请 sk_buff 数据结构的内存</span></span><br><span class="line">	skb = kmem_cache_alloc_node(cache, gfp_mask &amp; ~__GFP_DMA, node);</span><br><span class="line">	<span class="keyword">if</span> (!skb)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	prefetchw(skb);</span><br><span class="line"></span><br><span class="line">	size = SKB_DATA_ALIGN(size);</span><br><span class="line">  <span class="comment">// 申请数据区域的内存</span></span><br><span class="line">	data = kmalloc_node_track_caller(size + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> skb_shared_info), gfp_mask, node);</span><br><span class="line">	<span class="keyword">if</span> (!data)</span><br><span class="line">		<span class="keyword">goto</span> nodata;</span><br><span class="line">	prefetchw(data + size);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Only clear those fields we need to clear, not those that we will</span></span><br><span class="line"><span class="comment">	 * actually initialise below. Hence, don&#x27;t put any more fields after</span></span><br><span class="line"><span class="comment">	 * the tail pointer in struct sk_buff!</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="built_in">memset</span>(skb, <span class="number">0</span>, offsetof(<span class="keyword">struct</span> sk_buff, tail));</span><br><span class="line">	skb-&gt;truesize = size + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sk_buff);</span><br><span class="line">	<span class="type">atomic_set</span>(&amp;skb-&gt;users, <span class="number">1</span>);</span><br><span class="line">	skb-&gt;head = data;</span><br><span class="line">	skb-&gt;data = data;</span><br><span class="line">	skb_reset_tail_pointer(skb);</span><br><span class="line">	skb-&gt;end = skb-&gt;tail + size;</span><br><span class="line">	kmemcheck_annotate_bitfield(skb, flags1);</span><br><span class="line">	kmemcheck_annotate_bitfield(skb, flags2);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> NET_SKBUFF_DATA_USES_OFFSET</span></span><br><span class="line">	skb-&gt;mac_header = ~<span class="number">0U</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* make sure we initialize shinfo sequentially */</span></span><br><span class="line">	shinfo = skb_shinfo(skb);</span><br><span class="line">	<span class="built_in">memset</span>(shinfo, <span class="number">0</span>, offsetof(<span class="keyword">struct</span> skb_shared_info, dataref));</span><br><span class="line">	<span class="type">atomic_set</span>(&amp;shinfo-&gt;dataref, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (fclone) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">child</span> =</span> skb + <span class="number">1</span>;</span><br><span class="line">		<span class="type">atomic_t</span> *fclone_ref = (<span class="type">atomic_t</span> *) (child + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">		kmemcheck_annotate_bitfield(child, flags1);</span><br><span class="line">		kmemcheck_annotate_bitfield(child, flags2);</span><br><span class="line">		skb-&gt;fclone = SKB_FCLONE_ORIG;</span><br><span class="line">		<span class="type">atomic_set</span>(fclone_ref, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">		child-&gt;fclone = SKB_FCLONE_UNAVAILABLE;</span><br><span class="line">	&#125;</span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">return</span> skb;</span><br><span class="line">nodata:</span><br><span class="line">	kmem_cache_free(cache, skb);</span><br><span class="line">	skb = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在调用 <code>kmalloc</code> 之前，使用宏 <code>SKB_DATA_ALIGN</code> 调整了大小参数以强制对齐。返回之前，该函数将初始化结构体中的一些参数，从而产生下图所示的最终结果：</p>
<p><img src="https://s2.loli.net/2023/04/21/PKuO6jrDbCe8I3W.png" alt="alloc_skb function"></p>
<p>在图右侧存储块的底部，可以看到为了强制对齐而引入的 Padding 区域。 <code>skb_shared_info</code> 块主要用于处理 IP 的分片（IP 协议根据 MTU 和 MSS 对数据包进行的分片传输）。</p>
<p><code>__alloc_skb</code> 函数可以叫做 Fast SKB cloning 函数，这个函数存在的主要原因是，以前我们每次 <code>skb_clone</code> 一个 skb 的时候，都是要调用 <code>kmem_cache_alloc</code> 从 cache 中 alloc 一块新的内存。而现在当我们拥有了 fast clone 之后，通过调用 <code>alloc_skb_fclone</code> 函数来分配一块大于 <code>sizeof(struct sk_buff)</code> 的内存，也就是在这次请求的 skb 的下方多申请了一些内存，然后返回的时候设置返回的 skb 的 <code>fclone</code> 标记为 <code>SKB_FCLONE_ORIG</code>，而多申请的那块内存的 <code>sk_buff</code> 的 fclone 为 <code>SKB_FCLONE_UNAVAILABLE</code>，这样当我们调用 <code>skb_clone</code> 克隆这个 skb 的时候看到 fclone 的标记就可以直接将 skb 的指针+1,而不需要从 cache 中取了。这样的话节省了一次内存存取，提高了 clone 的效率，不过调用 flcone 一般都是我们确定接下来这个 skb 会被 clone 很多次。</p>
<p>更详细的 fclone 的介绍可以看<a target="_blank" rel="noopener" href="http://lwn.net/Articles/140552/">这里</a>。</p>
<h3 id="dev_alloc_skb" tabindex="-1" id="dev-alloc-skb">dev_alloc_skb</h3>
<p><code>dev_alloc_skb()</code> 也是一个缓冲区分配函数，它主要被设备驱动接收数据包时使用，通常用在中断上下文中。这是一个 <code>alloc_skb()</code> 的包装函数，它会在请求分配的大小上增加 <code>NET_SKB_PAD</code> 字节的空间以优化缓冲区的读写效率，它的分配要求使用 <code>gfp_mask</code>，为调用函数指定。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// allocate an skbuff for receiving</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *__<span class="title">dev_alloc_skb</span>(<span class="title">unsigned</span> <span class="title">int</span> <span class="title">length</span>, <span class="title">gfp_t</span> <span class="title">gfp_mask</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span> =</span> alloc_skb(length + NET_SKB_PAD, gfp_mask);</span><br><span class="line">	<span class="keyword">if</span> (likely(skb))</span><br><span class="line">		skb_reserve(skb, NET_SKB_PAD);</span><br><span class="line">	<span class="keyword">return</span> skb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="%E5%86%85%E5%AD%98%E9%87%8A%E6%94%BE" tabindex="-1" id="内存释放">内存释放</h2>
<h3 id="kfree_skb" tabindex="-1" id="kfree-skb">kfree_skb</h3>
<p><code>kfree_skb</code> 只有 <code>skb-&gt;users</code> 计数器为1时才释放，这里主要是判断一个引用标记位 <code>users</code>，将它减一，如果大于0则直接返回，否则释放 skb。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">kfree_skb</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (unlikely(!skb))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span> (likely(<span class="type">atomic_read</span>(&amp;skb-&gt;users) == <span class="number">1</span>))</span><br><span class="line">		smp_rmb();</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (likely(!atomic_dec_and_test(&amp;skb-&gt;users)))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	trace_kfree_skb(skb, __builtin_return_address(<span class="number">0</span>));</span><br><span class="line">	__kfree_skb(skb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>kfree_skb</code> 仅在 <code>skb-&gt;users</code> 计数器为1时（没有缓冲区的用户时）才释放缓冲区。 否则，该函数只会使该计数器递减。因此，如果一个缓冲区有三个用户，则只有当调用第三次 <code>dev_kfree_skb</code> 或 <code>kfree_skb</code> 时才会真正释放内存。</p>
<p><img src="https://s2.loli.net/2023/04/21/rgj6Ry3tsqPxwAe.png" alt="kfree_skb function"></p>
<h2 id="%E6%95%B0%E6%8D%AE%E4%BF%9D%E7%95%99%E5%92%8C%E5%AF%B9%E9%BD%90" tabindex="-1" id="数据保留和对齐">数据保留和对齐</h2>
<ul>
<li>skb_put：在数据域尾部追加一段空间</li>
<li>skb_push：在数据域的头部追加一段空间</li>
<li>skb_pull：将 <code>skb-&gt;data</code> 指针在数据域下移指定字节</li>
<li>skb_reserve：在 <code>sk_buff</code> 中 <code>skb-&gt;data</code> 之前的空间追加一段空间（在每层追加自己的协议头时常用到）</li>
</ul>
<p>下图为分别对 <code>sk_buff</code> 执行 <code>skb_put</code>(a)，<code>skb_push</code>(b)，<code>skb_pull</code>©，<code>skb_reserve</code>(d) 的前后对比：</p>
<p><img src="https://s2.loli.net/2023/04/21/cox8KyGBrSw2v1d.png" alt="Before and after: (a)skb_put, (b)skb_push, (c)skb_pull, and (d)skb_reserve"></p>
<h3 id="skb_put" tabindex="-1" id="skb-put">skb_put</h3>
<p>先来看 <code>__skb_put</code> 函数，可以看到它只是将 <code>tail</code> 指针移动 <code>len</code> 个位置，然后 <code>len</code> 也相应的增加 <code>len</code> 个大小。 以下均在 <code>/include/linux/skbuff.h</code> 中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">char</span> *__skb_put(<span class="keyword">struct</span> sk_buff *skb, <span class="type">unsigned</span> <span class="type">int</span> len)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> *tmp = skb_tail_pointer(skb);</span><br><span class="line">	SKB_LINEAR_ASSERT(skb);</span><br><span class="line">	skb-&gt;tail += len;</span><br><span class="line">	skb-&gt;len  += len;</span><br><span class="line">	<span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="skb_push" tabindex="-1" id="skb-push">skb_push</h3>
<p><code>__skb_push</code> 是将 <code>data</code> 指针向上移动 <code>len</code> 个位置，对应的 <code>len</code> 肯定也是增加 <code>len</code> 大小。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">char</span> *__skb_push(<span class="keyword">struct</span> sk_buff *skb, <span class="type">unsigned</span> <span class="type">int</span> len)</span><br><span class="line">&#123;</span><br><span class="line">	skb-&gt;data -= len;</span><br><span class="line">	skb-&gt;len  += len;</span><br><span class="line">	<span class="keyword">return</span> skb-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="skb_pull" tabindex="-1" id="skb-pull">skb_pull</h3>
<p><code>__skb_pull</code> 是将 <code>data</code> 指针向下移动 <code>len</code> 个位置，然后 <code>len</code> 减小 <code>len</code> 大小</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">char</span> *__skb_pull(<span class="keyword">struct</span> sk_buff *skb, <span class="type">unsigned</span> <span class="type">int</span> len)</span><br><span class="line">&#123;</span><br><span class="line">	skb-&gt;len -= len;</span><br><span class="line">	BUG_ON(skb-&gt;len &lt; skb-&gt;data_len);</span><br><span class="line">	<span class="keyword">return</span> skb-&gt;data += len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="skb_reserve" tabindex="-1" id="skb-reserve">skb_reserve</h3>
<p><code>__skb_reserve</code> 是将整个数据区，也就是 <code>data</code> 以及 <code>tail</code> 指针一起向下移动 <code>len</code> 大小。<code>skb_reserve</code> 在缓冲区的头部保留一些空间，通常用于允许插入协议头或强制将数据在某个边界上对齐。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">skb_reserve</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">	skb-&gt;data += len;</span><br><span class="line">	skb-&gt;tail += len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，<code>skb_reserve</code> 函数实际上并没有将任何内容移入或移出数据缓冲区，它只是更新两个指针。</p>
<p>查看以太网网卡驱动程序的代码（比如: <code>drivers/net/ethernet/3com/3c59x.c</code> <code>vortex_rx</code> 函数），你能看到它们在将任何数据存储在他们刚刚分配的缓冲区中之前都会使用以下命令：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">skb_reserve(skb, <span class="number">2</span>);	<span class="comment">/* Align IP on 16 byte boundaries */</span></span><br></pre></td></tr></table></figure>
<p>因为他们知道他们将要把协议头为 14 个字节的以太网帧复制到缓冲区中，所以参数 2 将缓冲区的 <code>head</code> 指针下移了 2 个字节。这将让紧跟在以太网头之后的 IP 头，从缓冲区的开头在 16 字节边界上对齐。</p>
<p><img src="https://s2.loli.net/2023/04/21/urwZ5E1y3U4soOx.png" alt="(a) before skb_reserve, (b) after skb_reserve, and (c) after copying the frame on the buffer"></p>
<p>下图展示了 <code>skb_reserve</code> 在数据从上到下传递（发送数据）时的作用（为下层协议在数据区的头部分配空间）：</p>
<p><img src="https://s2.loli.net/2023/04/21/qkhPyA9grEODTSa.png" alt="Buffer that is filled in while traversing the stack from the TCP layer down to the link layer"></p>
<ul>
<li>当要求 TCP 传输某些数据时，它会按照某些条件（TCP Max Segment Size(mss)，对分散收集 I/O 支持等）分配一个缓冲区。</li>
<li>TCP 在缓冲区的头部保留（通过调用 <code>skb_reserve</code>）足够的空间，以容纳所有层（TCP，IP，Link 层）的所有协议头。参数 <code>MAX_TCP_HEADER</code> 是所有级别的所有协议头的总和，并考虑到最坏的情况：因为 TCP 层不知道将使用哪种类型的接口进行传输，因此它为每个层保留最大的标头。它甚至考虑到多个 IP 协议头的可能性（因为当内核编译为支持 IP in IP 时，你可以拥有多个IP 协议头）。</li>
<li>TCP 的 payload （应用层传输的数据）被复制到缓冲区中。请注意上图只是个例子，TCP 的 payload 可以被不同地组织，例如可以将其存储为片段。</li>
<li>TCP 层添加它的协议头。</li>
<li>TCP 层将缓冲区移交给 IP 层，IP层也添加协议头。</li>
<li>IP 层将缓冲区移交给下一层，下一层也添加它的协议头。</li>
</ul>
<blockquote>
<p>请注意，当缓冲区在网络栈中向下移动时，每个协议会将 <code>skb-&gt;data</code> 指针向下移动，在其协议头中复制，并更新 <code>skb-&gt;len</code>。</p>
</blockquote>
<p><code>skb_push</code> 将一个数据块添加到缓冲区的开头，而 <code>skb_put</code> 将一个数据块添加到末尾。像 <code>skb_reserve</code> 一样，这些函数实际上并不会向缓冲区添加任何数据。他们只是将指针移到它的头或尾，数据填充应该由其他功能显式操作。<code>skb_pull</code> 通过将 <code>head</code> 指针向前移动来从缓冲区的头中删除数据块。</p>
<h3 id="skb_shared_info-%E7%BB%93%E6%9E%84%E4%BD%93-%26-skb_shinfo-%E5%87%BD%E6%95%B0" tabindex="-1" id="skb-shared-info-结构体-skb-shinfo-函数">skb_shared_info 结构体 &amp; skb_shinfo 函数</h3>
<p>在上面网卡驱动拷贝帧到缓冲区的例子中出现过 <code>skb_shared_info</code>。它是用来保留与数据域有关的其他信息。这个数据结构紧跟在标记数据域结束的 <code>end</code> 指针后面。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">skb_shared_info</span> &#123;</span></span><br><span class="line">    <span class="type">atomic_t</span>        dataref;  <span class="comment">// 代表数据域的用户数（数据域被引用的次数）</span></span><br><span class="line">    __u8            nr_frags;             <span class="comment">// 用于 ip fragmetation</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span>	*<span class="title">frag_list</span>;</span>           <span class="comment">// 用于 ip fragmetation</span></span><br><span class="line">    <span class="type">skb_frag_t</span>	    frags[MAX_SKB_FRAGS]; <span class="comment">// 用于 ip fragmetation</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>skb_is_nonlinear</code> 函数可用于检查缓冲区是否已分段，而 <code>skb_linearize</code> 函数可用于将多个片段合为单个缓冲区。</p>
<p><code>sk_buff</code> 中没有专门的指针指向 <code>skb_shared_info</code> 区域，<code>skb_shinfo</code> 函数就是方便得到指向 <code>skb_shared_info</code> 区域指针的函数:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> skb_shinfo(SKB)	((struct skb_shared_info *)(skb_end_pointer(SKB)))</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">char</span> *<span class="title function_">skb_end_pointer</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> sk_buff *skb)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> skb-&gt;end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="%E5%85%8B%E9%9A%86%E5%92%8C%E6%8B%B7%E8%B4%9D" tabindex="-1" id="克隆和拷贝">克隆和拷贝</h2>
<h3 id="skb_clone" tabindex="-1" id="skb-clone">skb_clone</h3>
<p>当相同的缓冲区需要由不同的消费者处理，并且他们可能更改 <code>sk_buff</code> 结构中的内容时，为了提高效率，<strong>内核并没有克隆缓冲区的结构和数据域</strong>，而是仅复制 <code>sk_buff</code> 的结构，并使用引用计数进行操作，以避免过早释放共享数据块。<code>skb_clone</code> 函数负责拷贝一个 buffer。使用克隆的一种情况是，需要将入口数据包分发给多个接收者，例如协议处理程序和一个或多个网络分接头（Network taps）。</p>
<p><code>sk_buff</code> 克隆不会链接到任何链表，也没有引用套接字所有者。克隆和原始缓冲区中的 <code>skb-&gt;cloned</code> 字段均设置为1。在克隆中将 <code>skb-&gt;users</code> 设置为1，以便第一次尝试删除它（被克隆的 <code>sk_buff</code>）时会成功，并且数据域的引用数（<code>dataref</code>）递增（因为现在有一个新的 <code>sk_buff</code> 指向了）。</p>
<p><code>skb_clone</code> 会调用 <code>__skb_clone</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *__<span class="title">skb_clone</span>(<span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">n</span>, <span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>) </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> C(x) n-&gt;x = skb-&gt;x </span></span><br><span class="line"><span class="comment">// 定义的宏，如果 x 是普通变量则是值赋值</span></span><br><span class="line"><span class="comment">// 如果 x 是指针，则是指向同一块区域</span></span><br><span class="line"></span><br><span class="line">	n-&gt;next = n-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">	n-&gt;sk = <span class="literal">NULL</span>;</span><br><span class="line">	__copy_skb_header(n, skb);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">	n-&gt;destructor = <span class="literal">NULL</span>;</span><br><span class="line">	C(tail);</span><br><span class="line">	C(end);</span><br><span class="line">	C(head);</span><br><span class="line">	C(head_frag);</span><br><span class="line">	C(data);    <span class="comment">// data 是一个指针, 所以没有克隆数据域，只是指向了数据域的内存地址</span></span><br><span class="line">	C(truesize);</span><br><span class="line">	refcount_set(&amp;n-&gt;users, <span class="number">1</span>); <span class="comment">//设置克隆的 sk_buff 的用户数为1</span></span><br><span class="line">	<span class="type">atomic_inc</span>(&amp;(skb_shinfo(skb)-&gt;dataref)); <span class="comment">//增加数据域的引用次数</span></span><br><span class="line">	skb-&gt;cloned = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> C</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下图为一个被分段（一个缓冲区，其中一些数据存储在与 <code>frags</code> 数组链接的数据片段中）了的缓冲区克隆的例子:</p>
<p><img src="https://s2.loli.net/2023/04/21/KtbcL7sxT2aoPg5.png" alt="skb_clone function"></p>
<h3 id="pskb_copy-%E4%B8%8E-skb_copy" tabindex="-1" id="pskb-copy-与-skb-copy">pskb_copy 与 skb_copy</h3>
<p>当缓冲区被克隆时，无法修改数据块的内容。这意味着代码无需做同步保证即可访问数据。但是，当一个函数不仅需要修改 <code>sk_buff</code> 结构的内容，还需要修改数据域时，就必须要克隆数据域了。如果真要修改数据域，开发者也有两个选项可用：</p>
<ol>
<li>当开发者知道自己仅仅需要修改的数据在 <code>skb-&gt;start</code> 和 <code>skb-&gt;end</code> 的区域时，开发者可以使用 <code>pskb_copy</code> 方法只克隆那个区域。</li>
<li>当开发者认为自己或许也需要修改分段数据域时，也就是 <code>skb_shared_info</code>，就必须使用 <code>skb_copy</code>。</li>
</ol>
<p><code>pskb_copy</code> 和 <code>skb_copy</code> 的不同如下图中的(a)和(b):</p>
<p><img src="https://s2.loli.net/2023/04/21/ISOGCoher1WVlu2.png" alt="(a) pskb_copy function and (b) skb_copy function"></p>
<p>在决定克隆或复制缓冲区时，每个子系统的程序员都无法预料其他内核组件（或其子系统的其他用户）是否需要该缓冲区中的原始信息。内核是非常模块化的，并且以非常动态和不可预测的方式进行更改，因此每个子系统都不知道其他子系统可以使用缓冲区做什么。因此，每个子系统的程序员只需跟踪他们对缓冲区所做的任何修改，并注意<strong>在修改任何内容之前先进行复制，以防内核的其他部分需要原始信息</strong>。</p>
<h2 id="%E9%98%9F%E5%88%97%E7%AE%A1%E7%90%86%E5%87%BD%E6%95%B0" tabindex="-1" id="队列管理函数">队列管理函数</h2>
<p>有一些函数用来维护 <code>sk_buff</code> 双向链表（也可以称为队列 queue）中的节点。下面是一些常用的功能函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// skb_queue_head - queue a buffer at the list head</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">skb_queue_head</span><span class="params">(<span class="keyword">struct</span> sk_buff_head *<span class="built_in">list</span>, <span class="keyword">struct</span> sk_buff *newsk)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"></span><br><span class="line">	spin_lock_irqsave(&amp;<span class="built_in">list</span>-&gt;lock, flags);</span><br><span class="line">	__skb_queue_head(<span class="built_in">list</span>, newsk);</span><br><span class="line">	spin_unlock_irqrestore(&amp;<span class="built_in">list</span>-&gt;lock, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// skb_queue_tail - queue a buffer at the list tail</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">skb_queue_tail</span><span class="params">(<span class="keyword">struct</span> sk_buff_head *<span class="built_in">list</span>, <span class="keyword">struct</span> sk_buff *newsk)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"></span><br><span class="line">	spin_lock_irqsave(&amp;<span class="built_in">list</span>-&gt;lock, flags);</span><br><span class="line">	__skb_queue_tail(<span class="built_in">list</span>, newsk);</span><br><span class="line">	spin_unlock_irqrestore(&amp;<span class="built_in">list</span>-&gt;lock, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// skb_dequeue - remove from the head of the queue</span></span><br><span class="line"><span class="keyword">struct</span> sk_buff *<span class="title function_">skb_dequeue</span><span class="params">(<span class="keyword">struct</span> sk_buff_head *<span class="built_in">list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">result</span>;</span></span><br><span class="line"></span><br><span class="line">	spin_lock_irqsave(&amp;<span class="built_in">list</span>-&gt;lock, flags);</span><br><span class="line">	result = __skb_dequeue(<span class="built_in">list</span>);</span><br><span class="line">	spin_unlock_irqrestore(&amp;<span class="built_in">list</span>-&gt;lock, flags);</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// skb_dequeue_tail - remove from the tail of the queue</span></span><br><span class="line"><span class="keyword">struct</span> sk_buff *<span class="title function_">skb_dequeue_tail</span><span class="params">(<span class="keyword">struct</span> sk_buff_head *<span class="built_in">list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">result</span>;</span></span><br><span class="line"></span><br><span class="line">	spin_lock_irqsave(&amp;<span class="built_in">list</span>-&gt;lock, flags);</span><br><span class="line">	result = __skb_dequeue_tail(<span class="built_in">list</span>);</span><br><span class="line">	spin_unlock_irqrestore(&amp;<span class="built_in">list</span>-&gt;lock, flags);</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// skb_queue_purge - empty a list</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">skb_queue_purge</span><span class="params">(<span class="keyword">struct</span> sk_buff_head *<span class="built_in">list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>;</span></span><br><span class="line">	<span class="keyword">while</span> ((skb = skb_dequeue(<span class="built_in">list</span>)) != <span class="literal">NULL</span>)</span><br><span class="line">		kfree_skb(skb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>操作队列的所有函数都必须保证是原子操作。也就是说，它们必须获取 <code>sk_buff_head</code> 结构提供的队列自旋锁。否则，它们可能会被异步事件中断，这些异步事件会使队列中的元素入队或出队，例如到期计时器调用的函数会导致争用条件。</p>
<h1 id="%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99" tabindex="-1">参考资料</h1>
<ul>
<li><a target="_blank" rel="noopener" href="https://wiki.linuxfoundation.org/networking/sk_buff">Linux Foundation Wiki: sk_buff</a></li>
<li>Understanding Linux Network Internals: Section 2.1. The Socket Buffer: sk_buff Structure</li>
</ul>
</div><div class="article-licensing box"><div class="licensing-title"><p>Linux 内核网络中的 sk_buff 数据结构</p><p><a href="https://universesaurora.top/2023/04/21/skbuff-repost/">https://universesaurora.top/2023/04/21/skbuff-repost/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>浮枕</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2023-04-21</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2023-04-21</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="" rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="CC BY" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="CC NC" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a><a class="icons" rel="noopener" target="_blank" title="CC SA" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><i class="icon fab fa-creative-commons-sa"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/%E5%86%85%E6%A0%B8/">内核</a><a class="link-muted mr-2" rel="tag" href="/tags/Linux/">Linux</a><a class="link-muted mr-2" rel="tag" href="/tags/%E7%BD%91%E7%BB%9C/">网络</a><a class="link-muted mr-2" rel="tag" href="/tags/sk-buff/">sk_buff</a></div><div class="sharethis-inline-share-buttons"></div><script src="https://platform-api.sharethis.com/js/sharethis.js#property=6291b3ba6ad7c40019490138&amp;product=sop" defer></script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/img/alipay.png" alt="支付宝"></span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/img/wechat.png" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2023/05/19/clangd-vsc-fault/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Apple Clangd 掉坑记</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2023/04/20/cfs-weight-nice/"><span class="level-item">CFS调度器、权重、优先级与虚拟时钟</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div id="comment-container"></div><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/gitalk/1.7.2/gitalk.css"><script src="https://cdnjs.loli.net/ajax/libs/gitalk/1.7.2/gitalk.min.js"></script><script>var gitalk = new Gitalk({
            id: "1ec782c7be08ded7e2f37b5b043dbb60",
            repo: "universesaurora-blog",
            owner: "UniversesAurora",
            clientID: "0d93b8fa7142b6c21de0",
            clientSecret: "fd1449c0798a980110bd15b1a5e35ea3d590d9aa",
            admin: ["UniversesAurora"],
            createIssueManually: false,
            distractionFreeMode: false,
            perPage: 20,
            pagerDirection: "last",
            
            
            enableHotKey: true,
            language: "zh-CN",
        })
        gitalk.render('comment-container')</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/avatar.png" alt="浮枕"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">浮枕</p><p class="is-size-6 is-block">Kernel panic at 0xffff467573696f6e</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>中央図書館断絶の壁分室</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">6</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">5</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">13</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://twitter.com/universesaurora" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Telegram" href="https://t.me/universesaurora"><i class="fab fa-telegram"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com/universesaurora"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/UniversesAurora"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="BiliBili" href="https://space.bilibili.com/211209824"><i class="fas fa-play"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Email" href="mailto:universesaurora@gmail.com"><i class="fas fa-envelope"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/%E5%86%85%E6%A0%B8/"><span class="level-start"><span class="level-item">内核</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%9D%82%E8%B0%88/"><span class="level-start"><span class="level-item">杂谈</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%A1%AC%E4%BB%B6/"><span class="level-start"><span class="level-item">硬件</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E9%80%86%E5%90%91/"><span class="level-start"><span class="level-item">逆向</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E9%9A%8F%E7%AC%94/"><span class="level-start"><span class="level-item">随笔</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Linux/"><span class="tag">Linux</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/clangd/"><span class="tag">clangd</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/llvm/"><span class="tag">llvm</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/nvdimm/"><span class="tag">nvdimm</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/sk-buff/"><span class="tag">sk_buff</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vscode/"><span class="tag">vscode</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%86%85%E6%A0%B8/"><span class="tag">内核</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%B8%B8%E6%88%8F/"><span class="tag">游戏</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%A1%AC%E4%BB%B6/"><span class="tag">硬件</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BD%91%E7%BB%9C/"><span class="tag">网络</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%B0%83%E5%BA%A6%E5%99%A8/"><span class="tag">调度器</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%80%86%E5%90%91/"><span class="tag">逆向</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%9A%8F%E7%AC%94/"><span class="tag">随笔</span><span class="tag">1</span></a></div></div></div></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2023/05/"><span class="level-start"><span class="level-item">五月 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/04/"><span class="level-start"><span class="level-item">四月 2023</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/07/"><span class="level-start"><span class="level-item">七月 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/06/"><span class="level-start"><span class="level-item">六月 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/05/"><span class="level-start"><span class="level-item">五月 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen is-sticky"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#layout-fields"><span class="level-left"><span class="level-item">1</span><span class="level-item">Layout Fields</span></span></a></li><li><a class="level is-mobile" href="#general-fields"><span class="level-left"><span class="level-item">2</span><span class="level-item">General Fields</span></span></a></li><li><a class="level is-mobile" href="#feature-specific-fields"><span class="level-left"><span class="level-item">3</span><span class="level-item">Feature-Specific Fields</span></span></a></li><li><a class="level is-mobile" href="#management-functions"><span class="level-left"><span class="level-item">4</span><span class="level-item">Management Functions</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="level-left"><span class="level-item">4.1</span><span class="level-item">内存分配</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#alloc_skb"><span class="level-left"><span class="level-item">4.1.1</span><span class="level-item">alloc_skb</span></span></a></li><li><a class="level is-mobile" href="#dev_alloc_skb"><span class="level-left"><span class="level-item">4.1.2</span><span class="level-item">dev_alloc_skb</span></span></a></li></ul></li><li><a class="level is-mobile" href="#%E5%86%85%E5%AD%98%E9%87%8A%E6%94%BE"><span class="level-left"><span class="level-item">4.2</span><span class="level-item">内存释放</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#kfree_skb"><span class="level-left"><span class="level-item">4.2.1</span><span class="level-item">kfree_skb</span></span></a></li></ul></li><li><a class="level is-mobile" href="#%E6%95%B0%E6%8D%AE%E4%BF%9D%E7%95%99%E5%92%8C%E5%AF%B9%E9%BD%90"><span class="level-left"><span class="level-item">4.3</span><span class="level-item">数据保留和对齐</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#skb_put"><span class="level-left"><span class="level-item">4.3.1</span><span class="level-item">skb_put</span></span></a></li><li><a class="level is-mobile" href="#skb_push"><span class="level-left"><span class="level-item">4.3.2</span><span class="level-item">skb_push</span></span></a></li><li><a class="level is-mobile" href="#skb_pull"><span class="level-left"><span class="level-item">4.3.3</span><span class="level-item">skb_pull</span></span></a></li><li><a class="level is-mobile" href="#skb_reserve"><span class="level-left"><span class="level-item">4.3.4</span><span class="level-item">skb_reserve</span></span></a></li><li><a class="level is-mobile" href="#skb_shared_info-%E7%BB%93%E6%9E%84%E4%BD%93-%26-skb_shinfo-%E5%87%BD%E6%95%B0"><span class="level-left"><span class="level-item">4.3.5</span><span class="level-item">skb_shared_info 结构体 &amp; skb_shinfo 函数</span></span></a></li></ul></li><li><a class="level is-mobile" href="#%E5%85%8B%E9%9A%86%E5%92%8C%E6%8B%B7%E8%B4%9D"><span class="level-left"><span class="level-item">4.4</span><span class="level-item">克隆和拷贝</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#skb_clone"><span class="level-left"><span class="level-item">4.4.1</span><span class="level-item">skb_clone</span></span></a></li><li><a class="level is-mobile" href="#pskb_copy-%E4%B8%8E-skb_copy"><span class="level-left"><span class="level-item">4.4.2</span><span class="level-item">pskb_copy 与 skb_copy</span></span></a></li></ul></li><li><a class="level is-mobile" href="#%E9%98%9F%E5%88%97%E7%AE%A1%E7%90%86%E5%87%BD%E6%95%B0"><span class="level-left"><span class="level-item">4.5</span><span class="level-item">队列管理函数</span></span></a></li></ul></li><li><a class="level is-mobile" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="level-left"><span class="level-item">5</span><span class="level-item">参考资料</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><figure class="media-left"><a class="image" href="/2023/05/19/clangd-vsc-fault/"><img src="https://cdn.pixabay.com/photo/2023/05/15/15/33/landscape-7995369_1280.jpg" alt="Apple Clangd 掉坑记"></a></figure><div class="media-content"><p class="date"><time dateTime="2023-05-19T07:51:21.000Z">2023-05-19</time></p><p class="title"><a href="/2023/05/19/clangd-vsc-fault/">Apple Clangd 掉坑记</a></p><p class="categories"><a href="/categories/%E6%9D%82%E8%B0%88/">杂谈</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2023/04/21/skbuff-repost/"><img src="https://cdn.pixabay.com/photo/2018/10/19/12/14/train-3758523_1280.jpg" alt="Linux 内核网络中的 sk_buff 数据结构"></a></figure><div class="media-content"><p class="date"><time dateTime="2023-04-21T02:22:53.000Z">2023-04-21</time></p><p class="title"><a href="/2023/04/21/skbuff-repost/">Linux 内核网络中的 sk_buff 数据结构</a></p><p class="categories"><a href="/categories/%E5%86%85%E6%A0%B8/">内核</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2023/04/20/cfs-weight-nice/"><img src="https://cdn.pixabay.com/photo/2016/08/26/12/44/houses-1622066_1280.jpg" alt="CFS调度器、权重、优先级与虚拟时钟"></a></figure><div class="media-content"><p class="date"><time dateTime="2023-04-20T13:47:32.000Z">2023-04-20</time></p><p class="title"><a href="/2023/04/20/cfs-weight-nice/">CFS调度器、权重、优先级与虚拟时钟</a></p><p class="categories"><a href="/categories/%E5%86%85%E6%A0%B8/">内核</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2022/07/18/nvdimm-intro/"><img src="https://s2.loli.net/2022/07/27/qNvb2iJmUzGPH1t.png" alt="nvdimm 技术与编程模型概览"></a></figure><div class="media-content"><p class="date"><time dateTime="2022-07-18T08:45:16.000Z">2022-07-18</time></p><p class="title"><a href="/2022/07/18/nvdimm-intro/">nvdimm 技术与编程模型概览</a></p><p class="categories"><a href="/categories/%E7%A1%AC%E4%BB%B6/">硬件</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2022/06/10/gi_research_metadata/"><img src="https://s2.loli.net/2022/06/10/ztySZrhFvx9wQfN.jpg" alt="小探 GI global-metadata"></a></figure><div class="media-content"><p class="date"><time dateTime="2022-06-10T12:07:34.000Z">2022-06-10</time></p><p class="title"><a href="/2022/06/10/gi_research_metadata/">小探 GI global-metadata</a></p><p class="categories"><a href="/categories/%E9%80%86%E5%90%91/">逆向</a></p></div></article></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">follow.it</h3><form action="https://api.follow.it/subscription-form/a1BGa2tQbURTbStQandqbGNOeWgzcytQME9iVityYVNVaVVGR2N5NzlGZDFaWDlHYnRLc0hmczZrVDFOY3dzamVYTDFIdGZxOVgvNTJwRm5RNjlqVVN5RzBNK0M1RVBUOEhlZXUwOEtyWG8vRVhPRUR4RFZFeUdwbTArSE0vdmF8dkswd0lGYUxxRGM0RHpnd280RDBtT3JXenNZQ2N6RG5oeVNjMjVTNitlcz0=/8" method="post" target="_blank"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://MoeClue.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Moeka</span></span><span class="level-right"><span class="level-item tag">moeclue.com</span></span></a></li><li><a class="level is-mobile" href="https://mou.best" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">小莫のBase</span></span><span class="level-right"><span class="level-item tag">mou.best</span></span></a></li></ul></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.png" alt="浮枕星海" height="28"></a><p class="is-size-7"><span>&copy; 2023 浮枕</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent " target="_blank" rel="noopener" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 icons" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><i class="fab fa-creative-commons"></i> <i class="fab fa-creative-commons-by"></i> <i class="fab fa-creative-commons-nc"></i> <i class="fab fa-creative-commons-sa"></i> </a></p></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-right",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.10.0/js/lightgallery.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdnjs.loli.net/ajax/libs/mathjax/2.7.9/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><div id="outdated"><h6>Your browser is out-of-date!</h6><p>Update your browser to view this website correctly.&amp;npsb;<a id="btnUpdateBrowser" target="_blank" rel="noopener" href="http://outdatedbrowser.com/">Update my browser now </a></p><p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">×</a></p></div><script src="https://cdnjs.loli.net/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.js" defer></script><script>window.addEventListener("load", function () {
            outdatedBrowser({
                bgColor: '#f25648',
                color: '#ffffff',
                lowerThan: 'object-fit' // display on IE11 or below
            });
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>