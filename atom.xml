<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>浮枕星海</title>
  
  <subtitle>浮枕 blog</subtitle>
  <link href="https://universesaurora.top/atom.xml" rel="self"/>
  
  <link href="https://universesaurora.top/"/>
  <updated>2024-09-29T23:15:16.000Z</updated>
  <id>https://universesaurora.top/</id>
  
  <author>
    <name>浮枕</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Bonjour 不 Bon：修复 Bonjour 中存在的 IPv6 栈溢出 bug</title>
    <link href="https://universesaurora.top/2024/09/29/bonjour_fix/"/>
    <id>https://universesaurora.top/2024/09/29/bonjour_fix/</id>
    <published>2024-09-29T23:15:16.000Z</published>
    <updated>2024-09-29T23:15:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>闲话少说，如果你在使用基于由 Apple 提供的 Bonjour 协议的服务（例如通过网络刷新 AltStore 应用，iTunes WiFi 同步等）时遇到无法正常连接的问题，并且查看 Windows 事件查看器的 Windows 日志中发现此应用程序错误（异常代码和错误偏移量一致）：</p><span id="more"></span><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">错误应用程序名称: mDNSResponder.exe，版本: 3.1.0.1，时间戳: 0x55cbcce6</span><br><span class="line">错误模块名称: mDNSResponder.exe，版本: 3.1.0.1，时间戳: 0x55cbcce6</span><br><span class="line">异常代码: 0xc0000409</span><br><span class="line">错误偏移量: 0x00000000000437c3</span><br><span class="line">错误进程 ID: 0x0x9BA8</span><br><span class="line">错误应用程序启动时间: 0x0x1DB1204029AD2A1</span><br><span class="line">错误应用程序路径: C:\Program Files\Bonjour\mDNSResponder.exe</span><br><span class="line">错误模块路径: C:\Program Files\Bonjour\mDNSResponder.exe</span><br><span class="line">报告 ID: 97706ac4-91ee-484e-a851-e12e37433bd0</span><br><span class="line">错误程序包全名: </span><br><span class="line">错误程序包相对应用程序 ID: </span><br></pre></td></tr></table></figure><p>那么<a href="https://1drv.ms/u/s!AiqwR6LDRXHbkytc6emn6FL0zUr3?e=rufbKu">下载这个</a>修复后的 <code>mDNSResponder.exe</code>，替换掉 <code>C:\Program Files\Bonjour\mDNSResponder.exe</code>，然后去服务里重启 Bonjour 服务即可。如果是 AltStore 刷新不了的问题，还需要在这之后重启 Altserver。</p><h1 id="%E9%97%AE%E9%A2%98%E8%83%8C%E6%99%AF" tabindex="-1">问题背景</h1><p>之前我在 Windows 上用代理软件一般不打开系统代理等设置，只通过 port 访问，然后通过 proxifier 或者手动设置 HTTP 代理（一般是命令行）方式访问代理。然而这种方式会带来一些问题：最主要就是有的软件用 HTTP 连不上用 SOCKS 却可以，或者反过来的情况，这就导致规则很难设置；还有就是有的规则要用全局有点规则要用分流导致要同时开两个代理软件等等。proxifier 有时候又会出现莫名奇妙地无法代理的问题，然后它这个软件原理又比较奇妙很难查明原因（不是用的系统设置中的代理设置，也没有创建网卡，感觉更像是注入），比如我最近代理 VRChat 的时候就有时候能用有时候用不了，查了半天也找不到原因…</p><p>之所以一直用着是一是因为我希望 Windows 上的软件尽量不走代理，我大部分的代理需求都来自浏览器，已经被 SmartProxy 这类扩展解决了，proxifier主要还是解决 Discord 这类不用代理就连不上的软件，或者 GitHub 这类域名等；二是因为我的系统上还有 Tailscale、Altserver 之类对本地网络由依赖的软件，我不太清楚用 TUN 这类方式会不会对它们造成干扰。</p><p>不过最近捣鼓 iOS 代理软件让我开始觉得 TUN 这种网络层代理才是更完美的代理方法，所以最终还是把 Windows 也换成了 TUN 代理模式。我目前用的代理软件是 Mihomo Party，内核是 Mihomo。</p><p>没过几天我就发现 AltStore 刷新软件时找不到 Altserver，Altserver 中也不显示 iOS 设备了。很快我就意识到这很可能是我前几天弄成 TUN 代理导致的。</p><p>我尝试关闭代理软件，这会删除创建的 TUN 网卡，然后重启 Altserver，但很奇怪的并没有作用。之前我遇到几次 Altserver 连接问题发现通过重启 Apple Mobile Device Service 服务可以修复，然而我尝试了很多次也没有作用。</p><p>然后我找到了<a href="https://github.com/clash-verge-rev/clash-verge-rev/issues/1445">这个 issue</a>，于是尝试关闭代理自启然后重启，此时连接恢复正常。但打开代理软件后，刚开始 AltStore 还可以正常刷新，过一会之后就又连不上了。</p><h1 id="%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90" tabindex="-1">抓包分析</h1><p>因为 AltServer 通过网络刷新应用需要通过 iTunes 开启 iOS 设备的“通过Wi-Fi 与此设备同步”选项，我知道它的工作原理其实是通过 Bonjour 协议发现设备。猜想是不是 Bonjour 协议在开了 TUN 之后不走物理网卡设备，或者 TUN 向 物理网卡转发导致了问题（我对 TUN 代理的工作原理不太熟悉，所以有很多猜想并不合理）。总之我打算用 Wireshark 抓包看下具体情况。</p><p>首先要说的是 Apple 的  Bonjour 协议本质上就是 mDNS（Multicast DNS）协议，走 UDP 的5353端口。当 mDNS 客户端需要解析主机名时，它会发送一条 IP 多播查询消息，要求具有该名称的主机识别自己的身份。然后，该目标机器多播一条包含其 IP 地址的消息。<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p><p>我先在 Bonjour 正常工作的情况下抓了下包，mDNS 在 IPv4/v6 下面都会工作，但目前我先只看 IPv4 的情况，于是我设置过滤规则 <code>mdns &amp;&amp; ip.addr == 192.168.2.100 || mdns &amp;&amp; ip.addr == 192.168.2.16</code>，<code>192.168.2.100</code> 是电脑的 IP，<code>192.168.2.16</code> 是 iOS 设备的 IP。</p><p>很快我就发现了目标，一些和 Altserver 有关的 mDNS 查询和回复：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">Internet Protocol Version 4, Src: 192.168.2.16, Dst: 224.0.0.251</span><br><span class="line">User Datagram Protocol, Src Port: 5353, Dst Port: 5353</span><br><span class="line">Multicast Domain Name System (query)</span><br><span class="line">    Transaction ID: 0x0000</span><br><span class="line">        [Expert Info (Warning/Protocol): DNS response missing]</span><br><span class="line">    Flags: 0x0000 Standard query</span><br><span class="line">    Questions: 1</span><br><span class="line">    Answer RRs: 0</span><br><span class="line">    Authority RRs: 0</span><br><span class="line">    Additional RRs: 0</span><br><span class="line">    Queries</span><br><span class="line">        MDDPC._altserver._tcp.local: type SRV, class IN, &quot;QU&quot; question</span><br><span class="line">            Name: MDDPC._altserver._tcp.local</span><br><span class="line">            [Name Length: 27]</span><br><span class="line">            [Label Count: 4]</span><br><span class="line">            Type: SRV (33) (Server Selection)</span><br><span class="line">            .000 0000 0000 0001 = Class: IN (0x0001)</span><br><span class="line">            1... .... .... .... = &quot;QU&quot; question: True</span><br><span class="line"></span><br><span class="line">Internet Protocol Version 4, Src: 192.168.2.100, Dst: 224.0.0.251</span><br><span class="line">User Datagram Protocol, Src Port: 5353, Dst Port: 5353</span><br><span class="line">Multicast Domain Name System (response)</span><br><span class="line">    Transaction ID: 0x0000</span><br><span class="line">        [Expert Info (Warning/Protocol): DNS response retransmission. Original response in frame 21609]</span><br><span class="line">    Flags: 0x8400 Standard query response, No error</span><br><span class="line">    Questions: 0</span><br><span class="line">    Answer RRs: 1</span><br><span class="line">    Authority RRs: 0</span><br><span class="line">    Additional RRs: 7</span><br><span class="line">    Answers</span><br><span class="line">        MDDPC._altserver._tcp.local: type SRV, class IN, cache flush, priority 0, weight 0, port 1382, target MDDPC.local</span><br><span class="line">    Additional records</span><br><span class="line">        MDDPC.local: type A, class IN, cache flush, addr 192.168.2.100</span><br><span class="line">        MDDPC.local: type AAAA, class IN, cache flush, addr 2001:0db8:85a3:0000:0000:8a2e:0370:7334</span><br><span class="line">        MDDPC.local: type AAAA, class IN, cache flush, addr 2001:0db8:85a3:0000:0000:abcd:ef12:3456</span><br><span class="line">        MDDPC.local: type AAAA, class IN, cache flush, addr 2001:0db8:85a3:0000:1234:5678:9abc:def0</span><br><span class="line">        MDDPC.local: type AAAA, class IN, cache flush, addr fe80::1a2b:3c4d:5e6f:7890</span><br><span class="line">        MDDPC.local: type NSEC, class IN, cache flush, next domain name MDDPC.local</span><br><span class="line">        MDDPC._altserver._tcp.local: type NSEC, class IN, cache flush, next domain name MDDPC._altserver._tcp.local</span><br><span class="line">    [Retransmitted response. Original response in: 21609]</span><br><span class="line">    [Retransmission: True]</span><br></pre></td></tr></table></figure><p>首先可以看到这两个报文的目的地址都是 <code>224.0.0.251</code>，这是固定的 mDNS 多播 IP 地址。iOS 设备向我的计算机（MDDPC）请求了 <code>_altserver</code> 这一 TCP 服务。而应答中返回了该服务的端口为 1382，通过 <code>MDDPC.local</code> 这一域名访问，同时在 <code>Additional records</code> 中将该域名对应的 IP 均列了出来。这就是 mDNS 大致的工作原理了。</p><p>接下来我在开启 TUN 的情况下进行抓包，由于此时多了一个 TUN 网卡，所以我分别同时在物理网卡和 TUN 网卡上同时进行抓包。</p><p>我在 TUN 网卡上确实抓到了一些 mDNS 包，但是没有和 Altserver 有关的包，而且都是计算机自己发送的，没有其他人响应。因为其实 TUN 网卡和物理网卡不在一个网段上，如下，物理网卡网段为 192.168，TAP 网卡为 198.18：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">未知适配器 Mihomo:</span><br><span class="line"></span><br><span class="line">   连接特定的 DNS 后缀 . . . . . . . :</span><br><span class="line">   描述. . . . . . . . . . . . . . . : Meta Tunnel</span><br><span class="line">   物理地址. . . . . . . . . . . . . : AA-BB-CC-DD-EE-FF</span><br><span class="line">   DHCP 已启用 . . . . . . . . . . . : 否</span><br><span class="line">   自动配置已启用. . . . . . . . . . : 是</span><br><span class="line">   IPv6 地址 . . . . . . . . . . . . : 2001:0db8:abcd::1(首选)</span><br><span class="line">   IPv4 地址 . . . . . . . . . . . . : 198.18.0.1(首选)</span><br><span class="line">   子网掩码  . . . . . . . . . . . . : 255.255.255.252</span><br><span class="line">   默认网关. . . . . . . . . . . . . : ::</span><br><span class="line">                                       0.0.0.0</span><br><span class="line">   DNS 服务器  . . . . . . . . . . . : 2001:0db8:abcd::2</span><br><span class="line">                                       198.18.0.2</span><br><span class="line">   TCPIP 上的 NetBIOS  . . . . . . . : 已启用</span><br><span class="line"></span><br><span class="line">以太网适配器 以太网:</span><br><span class="line"></span><br><span class="line">   连接特定的 DNS 后缀 . . . . . . . :</span><br><span class="line">   描述. . . . . . . . . . . . . . . : Intel(R) Ethernet Controller I226-V</span><br><span class="line">   物理地址. . . . . . . . . . . . . : 11-22-33-44-55-66</span><br><span class="line">   DHCP 已启用 . . . . . . . . . . . : 否</span><br><span class="line">   自动配置已启用. . . . . . . . . . : 是</span><br><span class="line">   IPv6 地址 . . . . . . . . . . . . : 2001:0db8:abcd::100(首选)</span><br><span class="line">   获得租约的时间  . . . . . . . . . : 2024年9月28日 21:37:00</span><br><span class="line">   租约过期的时间  . . . . . . . . . : 2024年9月30日 6:30:44</span><br><span class="line">   IPv6 地址 . . . . . . . . . . . . : 2001:0db8:abcd::200(首选)</span><br><span class="line">   临时 IPv6 地址. . . . . . . . . . : 2001:0db8:abcd::300(受到抨击)</span><br><span class="line">   临时 IPv6 地址. . . . . . . . . . : 2001:0db8:abcd::400(首选)</span><br><span class="line">   本地链接 IPv6 地址. . . . . . . . : fe80::1a2b:3c4d:5e6f:7890%21(首选)</span><br><span class="line">   IPv4 地址 . . . . . . . . . . . . : 192.168.2.100(首选)</span><br><span class="line">   子网掩码  . . . . . . . . . . . . : 255.255.255.0</span><br><span class="line">   默认网关. . . . . . . . . . . . . : fe80::8ede:f9ff:fead:6d81%21</span><br><span class="line">                                       192.168.2.1</span><br><span class="line">   DHCPv6 IAID . . . . . . . . . . . : 554221496</span><br><span class="line">   DHCPv6 客户端 DUID  . . . . . . . : 00-01-00-01-2C-28-7A-02-11-22-33-44-55-66</span><br><span class="line">   DNS 服务器  . . . . . . . . . . . : 2001:0db8::1</span><br><span class="line">                                       2001:0db8::2</span><br><span class="line">                                       119.29.29.29</span><br><span class="line">                                       223.5.5.5</span><br><span class="line">   TCPIP 上的 NetBIOS  . . . . . . . : 已启用</span><br></pre></td></tr></table></figure><p>在物理网卡上我抓到了来自 iOS 对 Altserver 的 mDNS 查询请求，但计算机并没有响应。</p><h1 id="%E8%B0%81%E6%98%AF-bonjour%EF%BC%9F" tabindex="-1">谁是 Bonjour？</h1><p>到这里我想看下到底是谁在监听5353端口，通过 <code>netstat -abn</code> 我发现监听 UDP 5353端口的程序不止一个，不太确定 Apple 的 Bonjour 由谁回复：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> [svchost.exe]</span><br><span class="line">  UDP    0.0.0.0:5353           *:* </span><br><span class="line"> [chrome.exe]</span><br><span class="line">  UDP    0.0.0.0:5353           *:*   </span><br><span class="line"> [svchost.exe]</span><br><span class="line">  UDP    192.168.2.100:5353     *:*                    </span><br><span class="line"> [nvcontainer.exe]</span><br><span class="line">  UDP    192.168.2.100:5353     *:*</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>于是我直接打开 Process Hacker 搜索 Bonjour，很快发现了一个叫做 <code>mDNSResponder.exe</code> 的程序，父进程是 <code>services.exe</code> ，他就是 Bonjour 服务。路径是 <code>C:\Program Files\Bonjour\mDNSResponder.exe</code>。</p><p><img src="https://s2.loli.net/2024/09/29/Hw4MRCloYxhWNjD.png" alt="Bonjour 服务"></p><p>打开 TUN 代理后，我发现 <code>mDNSResponder.exe</code> 很快就退出了。<code>C:\Program Files\Bonjour\</code> 目录下也没有发现有 log。因此我就去系统日志中寻找，于是找到了文章开头的错误日志。</p><p><img src="https://s2.loli.net/2024/09/29/kjrK9usXtPmbS1v.png" alt="错误日志"></p><p>看起来 <code>mDNSResponder.exe</code> 并非正常退出，否则一般也不会触发日志记录，并且是应用程序崩溃事件。这也解释了为什么关闭代理也无法恢复正常：Bonjour 服务并不会自动重启。在我关闭代理并手动启动 Bonjour 服务和 Altserver 后，果然一切恢复了正常。搜了下网上还有其他人也遇到过相同的错误：<a href="https://airvpn.org/forums/topic/51827-bonjour-service-crashes-when-eddie-active/">Bonjour Service Crashes when Eddie Active - Off-Topic - AirVPN</a></p><p>另外我发现 Clash for Windows 的 TUN 代理并不会导致 Bonjour 服务崩溃，这说明问题很可能并不出在 TUN 本身上。我又尝试更改 TUN 模式的设置，比如设置堆栈，自动全局路由，严格路由，DNS 劫持等等，但不管怎么改 <code>mDNSResponder.exe</code> 都会崩溃。</p><h1 id="%E9%80%86%E5%90%91%E6%97%B6%E9%97%B4" tabindex="-1">逆向时间</h1><p>为了搞明白问题出在哪里，我准备上 x64dbg 上分析一下。不过 <code>mDNSResponder.exe</code> 默认情况下是以服务程序模式执行的，没办法直接执行：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:\Users\Fusion\Downloads&gt; C:\<span class="string">&#x27;Program Files&#x27;</span>\Bonjour\mDNSResponder.exe</span><br><span class="line"><span class="built_in">start</span> service dispatcher failed (<span class="number">1063</span>)</span><br></pre></td></tr></table></figure><p>不过好在它提供了选项 <code>-server</code> 可以用于直接执行：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mDNSResponder <span class="number">1.0</span>d1</span><br><span class="line"></span><br><span class="line">    &lt;no args&gt;    Runs the service normally</span><br><span class="line">    <span class="literal">-install</span>     Creates the service and starts it</span><br><span class="line">    <span class="literal">-remove</span>      Stops the service and deletes it</span><br><span class="line">    <span class="literal">-start</span>       Starts the service dispatcher after processing all other arguments</span><br><span class="line">    <span class="literal">-server</span>      Runs the service directly as a server (<span class="keyword">for</span> debugging)</span><br><span class="line">    <span class="literal">-q</span>           Toggles Quiet Mode (no events or output)</span><br><span class="line">    <span class="literal">-remote</span>      Allow remote connections</span><br><span class="line">    <span class="literal">-cache</span> n     Number of mDNS cache entries (defaults to <span class="number">512</span>)</span><br><span class="line">    <span class="literal">-h</span>[<span class="type">elp</span>]      Display Help/Usage</span><br></pre></td></tr></table></figure><p>在 x64dbg 中添加参数 <code>-server</code> 后，就可以正常调试了。我发现它启动后很快触发了一个异常：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">EXCEPTION_DEBUG_INFO:  </span><br><span class="line">           dwFirstChance: 1  </span><br><span class="line">           ExceptionCode: C0000005 (EXCEPTION_ACCESS_VIOLATION)  </span><br><span class="line">          ExceptionFlags: 00000000  </span><br><span class="line">        ExceptionAddress: mdnsresponder.[00007FF64BE59D37](x64dbg://localhost/address64#00007FF64BE59D37)  </span><br><span class="line">        NumberParameters: 2  </span><br><span class="line">ExceptionInformation[00]: [0000000000000001](x64dbg://localhost/address64#0000000000000001) Write  </span><br><span class="line">ExceptionInformation[01]: [0000000000150000](x64dbg://localhost/address64#0000000000150000) Inaccessible Address  </span><br><span class="line">第一次异常于 [00007FF64BE59D37](x64dbg://localhost/address64#00007FF64BE59D37) (C0000005, EXCEPTION_ACCESS_VIOLATION)</span><br><span class="line"></span><br><span class="line"># 出错的指令</span><br><span class="line">00007FF64BE59D37 | 41:8810                 | mov byte ptr ds:[r8],dl                      | r8:&quot;Actx &quot;</span><br></pre></td></tr></table></figure><p>mov 指令访问了一个不可访问的地址，这个地址就是 r8 寄存器里的 0x150000，mov 试图将 dl 寄存器的内容写到这个地址。</p><p>这个地址是哪里呢，查看内存布局，可以看到该地址正好位于堆栈上方的只读内存段的开头。结合汇编和在 x64dbg 下的调试，这大概率是一个栈溢出错误。</p><p><img src="https://s2.loli.net/2024/09/30/hnYrCtyGOU4N6mv.png" alt="内存布局"></p><p>于是打开 IDA 开始分析，找到出错位置的伪代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( <span class="built_in">memcmp</span>(src, sa_family, i-&gt;Address.iSockaddrLength) )</span><br><span class="line">  &#123;</span><br><span class="line">    stack_mem_to_set_ff = <span class="number">0</span>i64;</span><br><span class="line">    v56 = <span class="number">0</span>i64;</span><br><span class="line">    stack_addr = &amp;stack_mem_to_set_ff;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( PrefixLength &lt; <span class="number">8</span> )</span><br><span class="line">        val_ff = <span class="number">-1</span> &lt;&lt; (<span class="number">8</span> - PrefixLength);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        val_ff = <span class="number">-1</span>;</span><br><span class="line">      *(_BYTE *)stack_addr = val_ff;<span class="comment">// crash here</span></span><br><span class="line">      stack_addr = (__int64 *)((<span class="type">char</span> *)stack_addr + <span class="number">1</span>);</span><br><span class="line">      PrefixLength -= <span class="number">8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( PrefixLength );</span><br></pre></td></tr></table></figure><p>上面代码已经被我解析过，比较容易能看到问题原因：<code>PrefixLength</code> 在非8的倍数时 while 循环永远不会结束，并且 <code>PrefixLength</code> 是一个 unsigned int，所以会把 <code>stack_mem_to_set_ff</code> 所在栈位置以上内存填充 <code>FF</code>，直到超过栈范围写入只读地址导致崩溃。</p><p>那么 <code>PrefixLength</code> 又是什么？这就要提到这部分代码开头调用的 <code>GetAdaptersAddresses</code> API了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">AdaptersAddresses = GetAdaptersAddresses(</span><br><span class="line">                          <span class="number">0</span>,</span><br><span class="line">                          <span class="number">0x3E</span>u,                <span class="comment">// 返回单播地址,返回此适配器上的 IP 地址前缀列表,返回默认网关的地址等</span></span><br><span class="line">                          <span class="number">0</span>i64,                 <span class="comment">// Reserved</span></span><br><span class="line">                          pLinkList_of_IP_ADAPTER_ADDRESSES,</span><br><span class="line">                          &amp;Size);</span><br><span class="line"></span><br><span class="line">pFirstPrefix = pLinkList_of_IP_ADAPTER_ADDRESSES_unwind2-&gt;FirstPrefix;</span><br><span class="line"></span><br><span class="line">IPHLPAPI_DLL_LINKAGE ULONG <span class="title function_">GetAdaptersAddresses</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in]      ULONG                 Family,</span></span><br><span class="line"><span class="params">  [in]      ULONG                 Flags,</span></span><br><span class="line"><span class="params">  [in]      PVOID                 Reserved,</span></span><br><span class="line"><span class="params">  [in, out] PIP_ADAPTER_ADDRESSES AdapterAddresses,</span></span><br><span class="line"><span class="params">  [in, out] PULONG                SizePointer</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>这个函数的定义具体见：<a href="https://learn.microsoft.com/en-us/windows/win32/api/iphlpapi/nf-iphlpapi-getadaptersaddresses">GetAdaptersAddresses function (iphlpapi.h) - Win32 apps | Microsoft Learn</a>，简单来说它会返回系统中所有网卡的详细信息。其中 <code>0x3E</code> 为 Flags 参数，其中有一位是 <code>GAA_FLAG_INCLUDE_PREFIX</code>，表示要求系统返回 IPv6 和 IPv4 地址的 IP 地址前缀。所有程序调用这个 API 返回的内容应该是一样的，所以我在 Visual Studio 中写了个测试程序调用该 API 来 debug。<code>PIP_ADAPTER_ADDRESSES-&gt;FirstPrefix</code> 中保存的就是这些前缀了，对于 mihomo TUN 内容如下：</p><p><img src="https://s2.loli.net/2024/09/30/aDZ98hQgJ6LxS4w.png" alt="mihomo TUN 的 FirstPrefix 结构"></p><p>可以看到所有 Prefix 通过 next 链接在一起，第二层 <code>PrefixLength</code> 为 <code>0x7e</code> 的 Prefix 就是问题所在，它并非8的倍数。</p><p>另外观察 <code>FirstPrefix-&gt;Address.lpSockaddr-&gt;sa_family</code> 成员，值为 <code>0x2</code> 代表 IPv4，<code>0x17</code> 代表 IPv6。<code>lpSockaddr</code> 这个成员是一个指向 <a href="https://learn.microsoft.com/en-us/windows/win32/winsock/sockaddr-2"><code>sockaddr</code> 结构体</a>的指针，这个结构体长度根据所选协议不同而有所不同，具体长度储存在 <code>Address.iSockaddrLength</code>中，但第一个成员永远是地址族。</p><p>网卡 IP 地址储存在 <code>PIP_ADAPTER_ADDRESSES-&gt;FirstUnicastAddress</code> 中，其结构和 Prefix 类似，由于网卡可能有多个 IP 地址，其也有多个 <code>sockaddr</code> 结构，通过链表组织在一起。</p><p>整体代码的逻辑是遍历所有网卡-&gt;遍历网卡的所有 IP 地址-&gt;遍历网卡所有地址前缀。其作用为找到所有网卡的所有IP对应的子网前缀。出错代码位于遍历网卡所有地址前缀的逻辑内，并且仅在 IP 地址为 IPv6 时才会执行，功能为生成前缀对应的掩码来计算子网前缀。</p><p>这也就解释了为什么 Clash for Windows 的 TAP 模式不会崩溃，因为即便打开了 IPv6 功能，它的 TAP 网卡依然没有 IPv6 地址，因此就不会执行到错误处。下图为 Clash TAP 的 <code>FirstUnicastAddress</code>，可以看到只有一个 IPv4 类型的地址：</p><p><img src="https://s2.loli.net/2024/09/30/eOukEG253aK6MNi.png" alt="Clash 只有 IPv4 地址"></p><p>那么如果关闭 mihomo 的 IPv6 功能呢？我测试了一下也不会报错，但查看网卡仍然有 IPv6 地址，此时查看所有 IPv6 Prefix 发现不再有非8倍数的 <code>PrefixLength</code> 了。另外物理网卡自动分配的 Prefix 长度也均为8的倍数。</p><p>问题的解决方案也很简单，只要将生成掩码的循环的判断条件从不为0修改为大于0即可。对应到汇编代码即将下图的 <code>jne</code> 指令修改为 <code>jg</code>，对应到程序文件就是将 <code>0x9140</code> 偏移处的 <code>75</code> 修改为 <code>7F</code>。</p><p><img src="https://s2.loli.net/2024/09/30/Zuex8yAXFPf7js6.png" alt="崩溃处汇编指令"></p><p><img src="https://s2.loli.net/2024/09/30/ILtHKNnBpeDOgT8.png" alt="修补文件对比"></p><h1 id="%E5%90%8E%E8%AF%9D" tabindex="-1">后话</h1><p>修好这个问题后我又去找了下，Bonjour 的源码其实已经被 Apple 公开了，感兴趣的可以去看下：</p><p><a href="https://github.com/apple-oss-distributions/mDNSResponder/tree/main/mDNSWindows">mDNSResponder/mDNSWindows at main · apple-oss-distributions/mDNSResponder · GitHub</a></p><p>本篇文章分析的代码对应的是 mDNSWin32.c 中的 <code>getifaddrs_ipv6</code>。该库中最新代码已经修复了这个问题。然而我并不知道这个修复的版本被用在了哪里，Bonjour 本身似乎并没有独立的安装包，我系统中的 Bonjour 是安装非 Windows 商店版本的 iTunes 时自带的（因为 Altserver 不支持商店版 iTunes）。也许是用在了现在商店版本的“Apple 设备”这个软件中？</p><p>另外，我还尝试构建了下这个最新的开源版本，很不幸并没有构建成功。如果可以的话还想试下用最新版本的 Bonjour 替换下，现在这个版本修改日期还是15年的，算下来都快10年了（天呐）。</p><p>那么就到这里吧，这些工作都是我一晚上肝出来的，说实话开始时没想到会走到通过逆向把它修好这步，感觉学到很多。</p><h1 id="%E5%8F%82%E8%80%83" tabindex="-1">参考</h1><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://en.wikipedia.org/wiki/Multicast_DNS">Multicast DNS - Wikipedia</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    
    <summary type="html">&lt;p&gt;闲话少说，如果你在使用基于由 Apple 提供的 Bonjour 协议的服务（例如通过网络刷新 AltStore 应用，iTunes WiFi 同步等）时遇到无法正常连接的问题，并且查看 Windows 事件查看器的 Windows 日志中发现此应用程序错误（异常代码和错误偏移量一致）：&lt;/p&gt;</summary>
    
    
    
    <category term="逆向" scheme="https://universesaurora.top/categories/%E9%80%86%E5%90%91/"/>
    
    
    <category term="网络" scheme="https://universesaurora.top/tags/%E7%BD%91%E7%BB%9C/"/>
    
    <category term="逆向" scheme="https://universesaurora.top/tags/%E9%80%86%E5%90%91/"/>
    
    <category term="代理" scheme="https://universesaurora.top/tags/%E4%BB%A3%E7%90%86/"/>
    
    <category term="Bonjour" scheme="https://universesaurora.top/tags/Bonjour/"/>
    
  </entry>
  
  <entry>
    <title>一次 Linux 5.4 内核启动失败分析</title>
    <link href="https://universesaurora.top/2024/05/18/initramfs_boot_fail/"/>
    <id>https://universesaurora.top/2024/05/18/initramfs_boot_fail/</id>
    <published>2024-05-18T15:25:38.000Z</published>
    <updated>2024-05-24T15:40:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>在我司一台 x86 服务器上遇到了一个奇怪的问题：这台服务器上一直以来使用的是从 linux-stable 主线的 lts 版本自行编译的内核，具体来说使用的是5.15.15版本内核。</p><p>由于驱动需要我尝试在上面编译和引导5.4.172内核，但无法正常启动，内核打印显示找不到任何分区。初步判断是硬盘控制器驱动没有加载，但是驱动已经以模块形式编译了（该服务器使用的是一个博通 RAID 控制器，对应驱动为 megaraid_sas）。</p><span id="more"></span><p>无奈我尝试将该驱动编译到内核，这次内核成功找到了所有分区，但却无法找到内核 cmdline 指定的 rootfs uuid：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">VFS: Cannot open root device <span class="string">&quot;UUID=xxxxxxxxx&quot;</span> or unknown-block(0,0): error -6</span><br><span class="line">Please append a correct <span class="string">&quot;root=&quot;</span> boot option; here are the available partitions:</span><br><span class="line">0800 34441003008 sda</span><br><span class="line">driver: sd</span><br><span class="line">0801 14680000 sda1 afc0d02a-b8be-407c-8ac6-ob3ac86a26d</span><br><span class="line">0802 101376 sda2 eef76d84-e51a-49cb-b16b-a76fa7155b13</span><br><span class="line">0803 16384 sda3 df9f72aa-cb58-blab-bl48f56be269</span><br><span class="line">0804 22021166 sda4 c11f17f3-7ac6-l667-aaf0-a748cfbc193d</span><br><span class="line">0805 31236209184 sda5 yyyyyyyyyy</span><br><span class="line"></span><br><span class="line">Kernel panic - not syncing: VFS: Unable to mount root fs on unknown-block(0,0)</span><br><span class="line">CPU:31 PID:1 <span class="built_in">comm</span> swapper/0 Not tainted 5.4.172 <span class="comment">#14</span></span><br><span class="line">Hardware name: Dell Inc. PowerEdge R750/04V528, BIOS 1.7.4 06/27/2022</span><br></pre></td></tr></table></figure><p>这里 rootfs 为 sda5，uuid <code>xxxxxxxxx</code> 通过检查 <code>blkid</code> 和 <code>lsblk -f</code> 输出可以确定是正确的。列表中 sda5 后的 uuid <code>yyyyyyyyyy</code> 与 <code>xxxxxxxxx</code> 并不相同，但在 <code>blkid</code> 输出中可以看到它是 sda5 的 <code>PARTUUID</code>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">% sudo blkid</span><br><span class="line">/dev/sda5: UUID=<span class="string">&quot;xxxxxxxxx&quot;</span> BLOCK_SIZE=<span class="string">&quot;4096&quot;</span> TYPE=<span class="string">&quot;ext4&quot;</span> PARTUUID=<span class="string">&quot;yyyyyyyyyy&quot;</span></span><br><span class="line">/dev/loop1: TYPE=<span class="string">&quot;squashfs&quot;</span></span><br><span class="line">/dev/loop19: TYPE=<span class="string">&quot;squashfs&quot;</span></span><br></pre></td></tr></table></figure><h1 id="partuuid-%E4%B8%8E-uuid" tabindex="-1">PARTUUID 与 UUID</h1><p>那么这里的 <code>PARTUUID</code> 是什么？</p><p>其实 <code>UUID</code> 指的是 <code>Filesystem UUID</code>，即文件系统 UUID；相对的 PARTUUID 指的就是 <code>Partition UUID</code>，即分区的 UUID。顾名思义 <code>Filesystem UUID</code> 是储存在文件系统中的，而 <code>Partition UUID</code> 是储存在分区表中的。</p><p>Linux 中的大多数文件系统都支持 Filesystem UUID，例如 ext2/3/4、XFS。但 FAT 和 NTFS 对 UUID 的支持可能没有那么好。<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>如果没有一个可用的 initramfs 或者 initramfs 为空，内核就无法获取<code>UUID</code>（也不能获取 <code>LABEL</code>，即卷标）<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>。</p><p>实际上，内核并不会处理 <code>UUID=</code> 这种标识符，而是会忽略该选项，由 initramfs 中的工具（如 udev）发现 <code>Filesystem UUID</code> 对应的设备并切换 rootfs。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Convert a name into device number.  We accept the following variants:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1) &lt;hex_major&gt;&lt;hex_minor&gt; device number in hexadecimal represents itself</span></span><br><span class="line"><span class="comment"> *         no leading 0x, for example b302.</span></span><br><span class="line"><span class="comment"> * 2) /dev/nfs represents Root_NFS (0xff)</span></span><br><span class="line"><span class="comment"> * 3) /dev/&lt;disk_name&gt; represents the device number of disk</span></span><br><span class="line"><span class="comment"> * 4) /dev/&lt;disk_name&gt;&lt;decimal&gt; represents the device number</span></span><br><span class="line"><span class="comment"> *         of partition - device number of disk plus the partition number</span></span><br><span class="line"><span class="comment"> * 5) /dev/&lt;disk_name&gt;p&lt;decimal&gt; - same as the above, that form is</span></span><br><span class="line"><span class="comment"> *    used when disk name of partitioned disk ends on a digit.</span></span><br><span class="line"><span class="comment"> * 6) PARTUUID=00112233-4455-6677-8899-AABBCCDDEEFF representing the</span></span><br><span class="line"><span class="comment"> *    unique id of a partition if the partition table provides it.</span></span><br><span class="line"><span class="comment"> *    The UUID may be either an EFI/GPT UUID, or refer to an MSDOS</span></span><br><span class="line"><span class="comment"> *    partition using the format SSSSSSSS-PP, where SSSSSSSS is a zero-</span></span><br><span class="line"><span class="comment"> *    filled hex representation of the 32-bit &quot;NT disk signature&quot;, and PP</span></span><br><span class="line"><span class="comment"> *    is a zero-filled hex representation of the 1-based partition number.</span></span><br><span class="line"><span class="comment"> * 7) PARTUUID=&lt;UUID&gt;/PARTNROFF=&lt;int&gt; to select a partition in relation to</span></span><br><span class="line"><span class="comment"> *    a partition with a known unique id.</span></span><br><span class="line"><span class="comment"> * 8) &lt;major&gt;:&lt;minor&gt; major and minor number of the device separated by</span></span><br><span class="line"><span class="comment"> *    a colon.</span></span><br><span class="line"><span class="comment"> * 9) PARTLABEL=&lt;name&gt; with name being the GPT partition label.</span></span><br><span class="line"><span class="comment"> *    MSDOS partitions do not support labels!</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If name doesn&#x27;t have fall into the categories above, we return (0,0).</span></span><br><span class="line"><span class="comment"> * block_class is used to check if something is a disk name. If the disk</span></span><br><span class="line"><span class="comment"> * name contains slashes, the device name has them replaced with</span></span><br><span class="line"><span class="comment"> * bangs.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">dev_t</span> <span class="title function_">name_to_dev_t</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span></span><br></pre></td></tr></table></figure><p>上面内核源码中的注释说明了内核能够处理的几种设备标识符，其中并没有 <code>UUID</code>，大概看了下应该是在 <code>md_setup_drive</code> 中调用 <code>name_to_dev_t</code> 来解析标识符。</p><p>也可以尝试把 <code>UUID</code> 更改为一个不存在的值，最终控制台将输出如下内容：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Begin: Loading essential drivers ... <span class="keyword">done</span>.</span><br><span class="line">Begin: Running /scripts/init-premount ... <span class="keyword">done</span>.</span><br><span class="line">Begin: Mounting root file system ... Begin: Running /scripts/local-top ... <span class="keyword">done</span>.</span><br><span class="line">Begin: Running /scripts/local-premount ... <span class="keyword">done</span>.</span><br><span class="line">Begin: Waiting <span class="keyword">for</span> root file system ... Begin: Running /scripts/local-block ... <span class="keyword">done</span>.</span><br><span class="line"><span class="keyword">done</span>.</span><br><span class="line">Gave up waiting <span class="keyword">for</span> root file system device.  Common problems:</span><br><span class="line"> - Boot args (<span class="built_in">cat</span> /proc/cmdline)</span><br><span class="line">   - Check rootdelay= (did the system <span class="built_in">wait</span> long enough?)</span><br><span class="line"> - Missing modules (<span class="built_in">cat</span> /proc/modules; <span class="built_in">ls</span> /dev)</span><br><span class="line">ALERT!  UUID=50303285-93e1-49a2-92a0-24868766cff1 does not exist.  Dropping to a shell!</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BusyBox v1.30.1 (Ubuntu 1:1.30.1-7ubuntu3) built-in shell (ash)</span><br><span class="line">Enter <span class="string">&#x27;help&#x27;</span> <span class="keyword">for</span> a list of built-in commands.</span><br><span class="line"></span><br><span class="line">(initramfs)</span><br></pre></td></tr></table></figure><p>很明显，这些输出内容是由 initramfs 中的程序或脚本输出的，内核本身并未输出错误信息。这也说明了 <code>UUID=</code> 标识符并非由内核处理。</p><p>内核中如果包含了所有所需的文件系统驱动，那么应该能够自行获得所有文件系统的 UUID，似乎并没有通过用户程序的必要。我也没有在网上发现这一做法的必要性的说法，因此推断该策略的目的可能是实现一定程度的解耦，毕竟正常情况下服务器系统都会加载 initramfs，而更精简的嵌入式领域则少有储存硬件变动的需求。通过用户程序控制该过程也能获得更多的灵活性。</p><p>这样看来，结合之前遇到的驱动问题，可以判断由于某些原因 initramfs 没有被正常加载，或者 initramfs 内容有误。</p><h1 id="%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-a%EF%BC%9A%E8%AE%A9-grub-%E4%BD%BF%E7%94%A8-partuuid-%E6%88%96%E8%B7%AF%E5%BE%84" tabindex="-1">解决方案 A：让 grub 使用 PARTUUID 或路径</h1><p>这里需要说明的是，使用 UUID 作为作为 rootfs 标识符是 grub 的默认行为。每当要从源码安装新内核时，一般做法是执行 <code>make install</code>，这背后执行了内核安装、DKMS模块编译、initramfs/initrd 生成、grub.cfg 生成等一系列操作。为了控制生成 grub.cfg 的默认行为，需要修改 /etc/default/grub 配置文件。</p><p>这里为了让 grub 在生成 grub.cfg 时使用路径（即 /dev/sdXX），可以在 /etc/default/grub 中添加：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GRUB_DISABLE_LINUX_UUID=<span class="literal">true</span></span><br></pre></td></tr></table></figure><p>但如果服务器的硬盘连接顺序发生变化（或者其他可能改变硬件拓扑的情况），rootfs 在系统中的路径就可能发生变化（如从 /dev/sda5 变为 /dev/sdb5），导致系统无法启动。这也是 grub 默认使用 UUID 的原因。</p><p>因此我们可以选择使用 <code>PARTUUID</code>，从 grub 2.04 版本<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>开始，支持了一个新的选项 <code>GRUB_DISABLE_LINUX_PARTUUID</code>，通过与 <code>GRUB_DISABLE_LINUX_UUID</code> 结合可以让 grub 使用 <code>PARTUUID</code> 作为标识符<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GRUB_DISABLE_LINUX_UUID=<span class="literal">true</span></span><br><span class="line">GRUB_DISABLE_LINUX_PARTUUID=<span class="literal">false</span></span><br></pre></td></tr></table></figure><p>另外要注意的是，只有 GPT 分区表才有标准的 UUID。MBR 来说并没有一个真正的 UUID，它的 PARTUUID 要短得多，因为它实际上是 PTUUID + 分区编号。因为它们不够长，无法确保唯一性，并且无法保证分区一定存在 PARTUUID。具体解释参见：<a href="https://unix.stackexchange.com/questions/751946/are-uuids-and-ptuuids-important-for-mbr-disks-if-so-how-do-i-create-them-on-my">partition - Are UUIDs and PTUUIDs important for MBR disks? If so, how do I create them on my own? - Unix &amp; Linux Stack Exchange</a></p><h1 id="%E5%88%86%E6%9E%90-initramfs-%E5%8A%A0%E8%BD%BD" tabindex="-1">分析 initramfs 加载</h1><p>解决方案 A 只是治标不治本，initramfs 被正常加载才是我们最终的目标。</p><p>对比了 5.4.172 和 5.15.15 内核打印的区别，在 5.15.15 中找到两条关键打印：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> RAMDISK: [mem 0x3900b000-0x3fffdfff]</span><br><span class="line">...</span><br><span class="line"> Trying to unpack rootfs image as initramfs...</span><br></pre></td></tr></table></figure><p>在内核中搜索了下，第一个打印来自于 <code>reserve_initrd</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __init <span class="title function_">reserve_initrd</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">/* Assume only end is not page aligned */</span></span><br><span class="line"> u64 ramdisk_image = get_ramdisk_image();</span><br><span class="line"> u64 ramdisk_size  = get_ramdisk_size();</span><br><span class="line"> u64 ramdisk_end   = PAGE_ALIGN(ramdisk_image + ramdisk_size);</span><br><span class="line"> u64 mapped_size;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (!boot_params.hdr.type_of_loader ||</span><br><span class="line">     !ramdisk_image || !ramdisk_size)</span><br><span class="line">  <span class="keyword">return</span>;  <span class="comment">/* No initrd provided by bootloader */</span></span><br><span class="line"></span><br><span class="line"> initrd_start = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> mapped_size = memblock_mem_size(max_pfn_mapped);</span><br><span class="line"> <span class="keyword">if</span> (ramdisk_size &gt;= (mapped_size&gt;&gt;<span class="number">1</span>))</span><br><span class="line">  panic(<span class="string">&quot;initrd too large to handle, &quot;</span></span><br><span class="line">         <span class="string">&quot;disabling initrd (%lld needed, %lld available)\n&quot;</span>,</span><br><span class="line">         ramdisk_size, mapped_size&gt;&gt;<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"> printk(KERN_INFO <span class="string">&quot;RAMDISK: [mem %#010llx-%#010llx]\n&quot;</span>, ramdisk_image,</span><br><span class="line">   ramdisk_end - <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>准备在内核中加入一些打印调试下，结果发现这次生成的内核出现了 unpack initrd 的打印，但仍然无法使用 UUID 启动。</p><p>尝试在自己的 Ubuntu 22.04 LTS 虚拟机（并且软件包均更新到最新版本）上也安装了5.4.172内核，意外发现与服务器上的现象一致。通过串口将错误现场的内核打印输出到文件中，发现以下打印：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[    1.839668] Unpacking initramfs...</span><br><span class="line">[    1.843910] Initramfs unpacking failed: invalid magic at start of compressed archive</span><br></pre></td></tr></table></figure><p>出现了明确的错误，这就很好解决了。在网上查了下该错误，是因为目前较新的发行版都使用 zstd 作为 initramfs 压缩算法，而该算法在 5.10 内核中才得到支持。<sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup></p><h1 id="%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-b%EF%BC%9A%E9%85%8D%E7%BD%AE%E4%BD%BF%E7%94%A8-gzip-%E5%8E%8B%E7%BC%A9-initramfs" tabindex="-1">解决方案 B：配置使用 gzip 压缩 initramfs</h1><p>对于 Ubuntu 来说，可以修改 <code>/etc/initramfs-tools/initramfs.conf</code> 文件，将 <code>COMPRESS=zstd</code> 修改为 <code>COMPRESS=gzip</code><sup class="footnote-ref"><a href="#fn6" id="fnref6">[6]</a></sup>。再次执行 <code>sudo make install</code> 或者 <code>sudo update-initramfs -c -k 5.4.172</code> 即可。</p><p>在服务器上修改了下，可以使用 UUID 标识 rootfs 了。但服务器之前并没有 unpack 出错的打印，打印内容也不太一样，根据代码来看是启用了 <code>CONFIG_BLK_DEV_RAM</code> 的原因：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (IS_ENABLED(CONFIG_BLK_DEV_RAM))</span><br><span class="line"> printk(KERN_INFO <span class="string">&quot;Trying to unpack rootfs image as initramfs...\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"> printk(KERN_INFO <span class="string">&quot;Unpacking initramfs...\n&quot;</span>);</span><br></pre></td></tr></table></figure><p>这个选项是给 initrd 使用的<sup class="footnote-ref"><a href="#fn7" id="fnref7">[7]</a></sup>，由于这里仅判断了该选项是否开启，所以和实际加载的是 initrd 还是 initramfs 并没有关系，这里我们使用的是 initramfs。</p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://www.linux.com/news/what-uuids-can-do-you/">What UUIDs can do for you - Linux.com</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p><a href="https://unix.stackexchange.com/questions/93767/why-cant-i-specify-my-root-fs-with-a-uuid#comment142167_93767">linux - Why can’t I specify my root fs with a UUID? - Unix &amp; Linux Stack Exchange</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p></li><li id="fn3" class="footnote-item"><p><a href="https://wiki.gentoo.org/wiki/GRUB/Configuration_variables">GRUB/Configuration variables - Gentoo Wiki</a> <a href="#fnref3" class="footnote-backref">↩︎</a></p></li><li id="fn4" class="footnote-item"><p><a href="https://forums.gentoo.org/viewtopic-t-1049514-start-0.html">Gentoo Forums - How to make GRUB pass PARTUUID to the kernel</a> <a href="#fnref4" class="footnote-backref">↩︎</a></p></li><li id="fn5" class="footnote-item"><p><a href="https://forum.manjaro.org/t/initramfs-unpacking-failed-invalid-magic-as-start-of-compressed/137451/3">Initramfs unpacking failed: invalid magic as start of compressed - Support - Manjaro Linux Forum</a> <a href="#fnref5" class="footnote-backref">↩︎</a></p></li><li id="fn6" class="footnote-item"><p><a href="https://askubuntu.com/questions/1277532/having-trouble-with-initramfs-unpacking-failed-decoding-failed-solutions">boot - Having trouble with “Initramfs unpacking failed: Decoding failed” solutions - Ask Ubuntu</a> <a href="#fnref6" class="footnote-backref">↩︎</a></p></li><li id="fn7" class="footnote-item"><p><a href="https://cateee.net/lkddb/web-lkddb/BLK_DEV_RAM.html">Linux Kernel Driver DataBase: CONFIG_BLK_DEV_RAM: RAM block device support</a> <a href="#fnref7" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    
    <summary type="html">&lt;p&gt;在我司一台 x86 服务器上遇到了一个奇怪的问题：这台服务器上一直以来使用的是从 linux-stable 主线的 lts 版本自行编译的内核，具体来说使用的是5.15.15版本内核。&lt;/p&gt;
&lt;p&gt;由于驱动需要我尝试在上面编译和引导5.4.172内核，但无法正常启动，内核打印显示找不到任何分区。初步判断是硬盘控制器驱动没有加载，但是驱动已经以模块形式编译了（该服务器使用的是一个博通 RAID 控制器，对应驱动为 megaraid_sas）。&lt;/p&gt;</summary>
    
    
    
    <category term="内核" scheme="https://universesaurora.top/categories/%E5%86%85%E6%A0%B8/"/>
    
    
    <category term="内核" scheme="https://universesaurora.top/tags/%E5%86%85%E6%A0%B8/"/>
    
    <category term="initramfs" scheme="https://universesaurora.top/tags/initramfs/"/>
    
  </entry>
  
  <entry>
    <title>Apple Clangd 掉坑记</title>
    <link href="https://universesaurora.top/2023/05/19/clangd_vsc_fault/"/>
    <id>https://universesaurora.top/2023/05/19/clangd_vsc_fault/</id>
    <published>2023-05-19T07:51:21.000Z</published>
    <updated>2023-05-19T12:33:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>clangd 是 llvm 项目推出的 C/C++ 语言服务器，通过 LSP（Language Server Protocal）协议向编辑器如 vscode/vim/emacs 提供语法补全、错误检测、跳转、格式化等等功能。据说是比 vscode 自己的 IntelliSense 更好一些，我开始用 clangd 的时候 IntelliSense 貌似还不支持使用 <code>compile_commands.js</code> 文件辅助代码分析，因此并没有具体对比过两者的差异。</p><p>macOS 上附带的 llvm 是 Apple 自己管理的，属于 Xcode 的一部分，这个版本其实是落后于主线版本很多的。理论上来说这种等待上游稳定后再选择使用的版本稳定性更好，问题会比较少，然而意外的这次在更新了 Xcode 后 clangd 就翻车了。</p><span id="more"></span><p>我个人比较喜欢在 vscode 上配合 clangd 插件阅读内核代码（虽然在工作时只能用 vim + ctags 这种古朴的方式，不过 tag 文件确实更灵活些，尤其是需要看不同架构的代码实现时）。为了获得更精确的分析，一般我会在 make 时配合 bear 生成 <code>compile_commands.js</code> 文件，用于辅助 clangd 语法分析。这样几乎所有符号都能正确解析，对分析代码有很大的帮助。并且分析过程不需要编译，可以把 <code>compile_commands.js</code> 文件稍微修改一下，拿到其他安装了 llvm 的平台上也可以工作的很好。</p><p>前几天 Xcode 在后台自动更新了，今天打开 vscode 时顺手更新了下 vscode，重新启动后 clangd 提供的代码分析功能就完全坏掉了。</p><p>一开始 clangd 一直在报 <code>Error while reading shard xxx.c: wrong version: want 17, got 16</code> 这个错。我猜测可能是更新了 Xcode 后缓存的某些文件的版本和当前不符导致的，于是删除了项目目录下的 <code>.cache</code> <code>.tmp_*</code> 之类的文件，然后这个报错就消失了，但是 clangd 插件还是报告崩溃（我也很崩溃…</p><p>打开输出窗口看了下 clangd 插件的日志，报了一个 <code>Signalled during AST worker action: InlayHints</code> 错误，看起来是被某个信号中断了（其实当时通过这个大概能推测到是某个 bug 导致访问了非法内存地址）。这里 InlayHints 其实指的就是 vscode 中指针处在符号上方后会跳出来的悬浮嵌入提示，也就是 clangd 插件向 clangd server 请求提示信息时发生的错误。</p><p><img src="https://s2.loli.net/2024/04/03/coFzrZBxiG4RV5k.png" alt="错误输出"></p><p>Google 了下只找到了一个似乎比较符合目前情况的 <a href="https://github.com/clangd/clangd/issues/1120">issue</a>，很巧的是他也是在用 clangd 分析内核代码时出现的（而且是访问了空指针导致的）。</p><p>不过我的输出中并没有栈回溯，不知道是不是 Apple 版的 clangd 去掉了栈回溯打印，因此还不能完全确定就是同一个问题。不过他提到了错误是 <code>EXPORT_SYMBOL</code> 宏展开后的代码导致的问题，因此我只留下两个没有 <code>EXPORT_SYMBOL</code> 宏的源文件，重启 vscode…</p><p><img src="https://s2.loli.net/2024/04/03/YN9UocWt63AH7xI.png" alt="没有 EXPORT_SYMBOL，一切正常"></p><p>这次并没有崩溃，嵌入提示也在这个源文件中正常工作了。目前差不多能确定是同一个问题了，为了再次确认下，我想到既然他自己不打印，我可以挂 lldb 自己看啊～</p><p><img src="https://s2.loli.net/2024/04/03/Mkzj4SXOWvdmcDY.png" alt="挂上 lldb"></p><p>只见我一个 attach，马上抓到了内存访问异常——</p><p><img src="https://s2.loli.net/2024/04/03/vWR2qg5NFxYAS64.png" alt="异常栈回溯"></p><p>直接贴一下内容：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">(lldb) c</span><br><span class="line">Process <span class="number">27639</span> resuming</span><br><span class="line">Process <span class="number">27639</span> stopped</span><br><span class="line">* thread #<span class="number">15</span>, name = <span class="string">&#x27;ASTWorker:dev.c&#x27;</span>, stop reason = <span class="built_in">EXC_BAD_ACCESS</span> (code=<span class="number">1</span>, address=<span class="number">0x8</span>)</span><br><span class="line">    frame #<span class="number">0</span>: <span class="number">0x0000000109a31953</span> clangd`clang::RecursiveASTVisitor&lt;clang::clangd::(anonymous <span class="keyword">namespace</span>)::InlayHintVisitor&gt;::<span class="built_in">TraverseDecl</span>(clang::Decl*) + <span class="number">12051</span></span><br><span class="line">clangd`clang::RecursiveASTVisitor&lt;clang::clangd::(anonymous <span class="keyword">namespace</span>)::InlayHintVisitor&gt;::TraverseDecl:</span><br><span class="line">-&gt;  <span class="number">0x109a31953</span> &lt;+<span class="number">12051</span>&gt;: movl   <span class="number">0x8</span>(%rdx), %edx</span><br><span class="line">    <span class="number">0x109a31956</span> &lt;+<span class="number">12054</span>&gt;: movq   %r13, %rdi</span><br><span class="line">    <span class="number">0x109a31959</span> &lt;+<span class="number">12057</span>&gt;: movq   %r15, %rsi</span><br><span class="line">    <span class="number">0x109a3195c</span> &lt;+<span class="number">12060</span>&gt;: callq  <span class="number">0x109a4dcf0</span>               ; clang::clangd::(anonymous <span class="keyword">namespace</span>)::InlayHintVisitor::<span class="built_in">addReturnTypeHint</span>(clang::FunctionDecl*, clang::SourceLocation)</span><br><span class="line">Target <span class="number">0</span>: (clangd) stopped.</span><br><span class="line">(lldb) bt</span><br><span class="line">* thread #<span class="number">15</span>, name = <span class="string">&#x27;ASTWorker:dev.c&#x27;</span>, stop reason = <span class="built_in">EXC_BAD_ACCESS</span> (code=<span class="number">1</span>, address=<span class="number">0x8</span>)</span><br><span class="line">  * frame #<span class="number">0</span>: <span class="number">0x0000000109a31953</span> clangd`clang::RecursiveASTVisitor&lt;clang::clangd::(anonymous <span class="keyword">namespace</span>)::InlayHintVisitor&gt;::<span class="built_in">TraverseDecl</span>(clang::Decl*) + <span class="number">12051</span></span><br><span class="line">    frame #<span class="number">1</span>: <span class="number">0x0000000109a31cb8</span> clangd`clang::RecursiveASTVisitor&lt;clang::clangd::(anonymous <span class="keyword">namespace</span>)::InlayHintVisitor&gt;::<span class="built_in">TraverseDecl</span>(clang::Decl*) + <span class="number">12920</span></span><br><span class="line">    frame #<span class="number">2</span>: <span class="number">0x0000000109a2e680</span> clangd`clang::clangd::<span class="built_in">inlayHints</span>(clang::clangd::ParsedAST&amp;, llvm::Optional&lt;clang::clangd::Range&gt;) + <span class="number">336</span></span><br><span class="line">    frame #<span class="number">3</span>: <span class="number">0x0000000109949909</span> clangd`<span class="type">void</span> llvm::detail::UniqueFunctionBase&lt;<span class="type">void</span>, llvm::Expected&lt;clang::clangd::InputsAndAST&gt; &gt;::CallImpl&lt;clang::clangd::ClangdServer::<span class="built_in">inlayHints</span>(llvm::StringRef, llvm::Optional&lt;clang::clangd::Range&gt;, llvm::unique_function&lt;<span class="built_in">void</span> (llvm::Expected&lt;std::__1::vector&lt;clang::clangd::InlayHint, std::__1::allocator&lt;clang::clangd::InlayHint&gt; &gt; &gt;)&gt;)::$_21&gt;(<span class="type">void</span>*, llvm::Expected&lt;clang::clangd::InputsAndAST&gt;&amp;) + <span class="number">89</span></span><br><span class="line">    frame #<span class="number">4</span>: <span class="number">0x0000000109af3ae4</span> clangd`<span class="type">void</span> llvm::detail::UniqueFunctionBase&lt;<span class="type">void</span>&gt;::CallImpl&lt;clang::clangd::(anonymous <span class="keyword">namespace</span>)::ASTWorker::<span class="built_in">runWithAST</span>(llvm::StringRef, llvm::unique_function&lt;<span class="built_in">void</span> (llvm::Expected&lt;clang::clangd::InputsAndAST&gt;)&gt;, clang::clangd::TUScheduler::ASTActionInvalidation)::$_7&gt;(<span class="type">void</span>*) + <span class="number">1524</span></span><br><span class="line">    frame #<span class="number">5</span>: <span class="number">0x0000000109aeb56a</span> clangd`clang::clangd::(anonymous <span class="keyword">namespace</span>)::ASTWorker::<span class="built_in">runTask</span>(llvm::StringRef, llvm::function_ref&lt;<span class="built_in">void</span> ()&gt;) + <span class="number">522</span></span><br><span class="line">    frame #<span class="number">6</span>: <span class="number">0x0000000109ae953a</span> clangd`<span class="type">void</span> llvm::detail::UniqueFunctionBase&lt;<span class="type">void</span>&gt;::<span class="built_in">CallImpl</span>&lt;clang::clangd::(anonymous <span class="keyword">namespace</span>)::ASTWorker::<span class="built_in">create</span>(llvm::StringRef, clang::clangd::GlobalCompilationDatabase <span class="type">const</span>&amp;, clang::clangd::TUScheduler::ASTCache&amp;, clang::clangd::TUScheduler::HeaderIncluderCache&amp;, clang::clangd::AsyncTaskRunner*, clang::clangd::Semaphore&amp;, clang::clangd::TUScheduler::Options <span class="type">const</span>&amp;, clang::clangd::ParsingCallbacks&amp;)::$_4&gt;(<span class="type">void</span>*) + <span class="number">4250</span></span><br><span class="line">    frame #<span class="number">7</span>: <span class="number">0x0000000109c6ec37</span> clangd`<span class="type">void</span>* llvm::thread::ThreadProxy&lt;std::__1::tuple&lt;clang::clangd::AsyncTaskRunner::<span class="built_in">runAsync</span>(llvm::Twine <span class="type">const</span>&amp;, llvm::unique_function&lt;<span class="built_in">void</span> ()&gt;)::$_4&gt; &gt;(<span class="type">void</span>*) + <span class="number">71</span></span><br><span class="line">    frame #<span class="number">8</span>: <span class="number">0x00007ff811b31259</span> libsystem_pthread.dylib`_pthread_start + <span class="number">125</span></span><br><span class="line">    frame #<span class="number">9</span>: <span class="number">0x00007ff811b2cc7b</span> libsystem_pthread.dylib`thread_start + <span class="number">15</span></span><br></pre></td></tr></table></figure><p>和这个 issue 的栈回溯基本完全一致，到此我们确认了问题。</p><p>不过我还有最后一个疑问，这个 issue 被提出来的时间距今已过去一年了。我确认了下 clangd 的版本，clangd 的版本号和 clang 是一致的，我系统中的版本目前是 14.0.3。目前 llvm 主线已经到 16.0.4 了，而主线的 14.0.3 是在2022年4月29日发布的。也就是说 Apple 的 llvm 落后于主线大概一年，而这个问题的修复 commit 刚好在 14.0.3 发布的一周后，也就是说并不包括在 14.0.3 中。不过话说这么久的必现崩溃问题不应该早就向后移植了吗，难道 Apple 的 llvm 团队在更新的时候只把编译器相关的问题向后移植了下，这个小小（？）的 clangd 问题就忽略了？</p><p><img src="https://s2.loli.net/2024/04/03/rkCaAnHJfF8Usx6.png" alt="clangd 版本"></p><p><img src="https://s2.loli.net/2024/04/03/r7gdKfTjLyw4SD1.png" alt="Xcode 版本"></p><p>又去<a href="https://xcodereleases.com/alpha.html">这个网站</a>看了下 Xcode 版本对应的 Clang 版本，最新一次 Xcode 更新确实将 clang 从 14.0.0 更新到了 14.0.3，这一切也就说得通了。</p><p>最后我用 brew 安装了最新的 llvm 版本解决了这个问题。不过默认 brew 安装的版本并不会出现在 PATH 中（这点很好，毕竟 macOS 上 Xcode 之类主要用的还是这个版本，并且安装时也提示了混用版本可能出现问题），需要在 VScode 的 clangd 插件里指定了下使用 brew 安装的 <code>/usr/local/opt/llvm/bin/clangd</code> 路径上的 clangd。</p><p>终于，clangd 愉快的跑了起来，vscode 的嵌入提示也能正常显示了！</p><p><img src="https://s2.loli.net/2024/04/03/xQSbC6e32vO7YHB.png" alt="恢复正常了！可喜可贺！"></p><p>这个问题也让我想到了之前看到老雷发现的 Visual Studio 问题也是访问空指针（具体<a href="https://mp.weixin.qq.com/s/ezPkE6ZUNr5lQFRGSwRI_A">在这</a>），即便是大公司发布的看起来可靠稳定的开发工具有时候还是会出 bug 的 ^ ^</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;clangd 是 llvm 项目推出的 C/C++ 语言服务器，通过 LSP（Language Server Protocal）协议向编辑器如 vscode/vim/emacs 提供语法补全、错误检测、跳转、格式化等等功能。据说是比 vscode 自己的 IntelliSense 更好一些，我开始用 clangd 的时候 IntelliSense 貌似还不支持使用 &lt;code&gt;compile_commands.js&lt;/code&gt; 文件辅助代码分析，因此并没有具体对比过两者的差异。&lt;/p&gt;
&lt;p&gt;macOS 上附带的 llvm 是 Apple 自己管理的，属于 Xcode 的一部分，这个版本其实是落后于主线版本很多的。理论上来说这种等待上游稳定后再选择使用的版本稳定性更好，问题会比较少，然而意外的这次在更新了 Xcode 后 clangd 就翻车了。&lt;/p&gt;</summary>
    
    
    
    <category term="杂谈" scheme="https://universesaurora.top/categories/%E6%9D%82%E8%B0%88/"/>
    
    
    <category term="vscode" scheme="https://universesaurora.top/tags/vscode/"/>
    
    <category term="clangd" scheme="https://universesaurora.top/tags/clangd/"/>
    
    <category term="llvm" scheme="https://universesaurora.top/tags/llvm/"/>
    
  </entry>
  
  <entry>
    <title>Linux 内核网络中的 sk_buff 数据结构</title>
    <link href="https://universesaurora.top/2023/04/21/skbuff_repost/"/>
    <id>https://universesaurora.top/2023/04/21/skbuff_repost/</id>
    <published>2023-04-21T02:22:53.000Z</published>
    <updated>2023-04-21T08:03:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文转载自 <a href="https://houmin.cc/">houmin.cc</a>，原文已被删除，但因为之前阅读此文感觉说明较为清楚（后来查了下主要参考的是 Understanding Linux Network Internals 这本书），因此为方便今后查看，从 <a href="https://web.archive.org/web/20220529013919/https://houmin.cc/posts/bec07334/">wayback machine</a> 找到并转载了这篇文章。文章内容可能有补充修正。</p><p>在 Linux 内核的网络代码中，<code>sk_buff</code> 或许是最重要的数据结构，用来表示已接收或将要传输的数据。 <code>sk_buff</code> 定义在 <code>include/linux/skbuff.h</code> 中，它由许多变量组成，目标就是满足所有网络协议的需要。随着数据包在内核协议栈不同层次传递时，Linux 内核不是通过层与层之间的数据拷贝，而是通过追加头信息的方式，这即是 <code>sk_buff</code> 被使用的典型场景：在不同网络协议层之间移动，通过添加数据头的形式传递数据。本文分析采用的是 2.6.35 版本内核。</p><span id="more"></span><p>随着内核的迭代，<code>sk_buff</code> 的结构已经被添加了许多新的选项，已经存在的字段也被重新整理了很多遍。可将内部的字段分为以下几类：</p><ul><li>Layout 负责内存布局的字段</li><li>General 通用的字段</li><li>Feature-specific 对应特别功能字段</li><li>Management functions 一些用来管理 sk_buff 的函数</li></ul><p><code>sk_buff</code> 在不同的网络层次被使用（MAC 或其他在 L2 的协议，在 L3 的 IP 协议，在 L4 的 TCP 或 UDP 等），当它从一层传递到另一层时，各个字段也会发生变化。在被传递到 L3 之前，L4 会追加头信息，然后在被传递到 L2 之前，L3 会追加头信息。<strong>从一层传递到另一层时，通过追加头信息的方式比将数据在层之间拷贝会更有效率</strong>。由于要在 buff 的开头增加空间（与平时常见的在尾部追加空间相比）是一项复杂的操作，内核便提供了 <code>skb_reserve</code> 函数执行这个操作。因此，随着 buffer 从上层到下层的传递，每层协议做的第一件事就是调用 <code>skb_reserve</code> 去为它们的协议头在 buffer 的头部分配空间。在后面，我们将通过一个例子去了解内核如何在当 buffer 在各个层间传递时，确保为每一层保留了足够的空间让它们添加它们自己的协议头。</p><p>在接收数据时，buffer 会被从下层到上层传递，在从下到上的过程中，前一层的协议头对于当前层来说已经没有用了。比如：L2 的协议头只会被处理 L2 协议的设备驱动程序使用，L3 并不关心 L2 的头。那么内核怎么做的呢? 内核的实现是： <strong><code>sk_buff</code> 中有一个指针会指向当前位于的层次的协议的协议头的内存开始地址，于是从 L2 到 L3 时，只需将指向 L2 头部的指针移动到 L3 的头部即可</strong>（又是一步追求效率的操作）。</p><h1 id="layout-fields" tabindex="-1">Layout Fields</h1><p>Linux 内核把系统中所有的 <code>sk_buff</code> 实例维护在一个双向链表中。和任何双向链表类似，<code>sk_buff</code> 链表的每个节点也通过 <code>next</code> 和 <code>prev</code> 分别指向后继和前驱节点。但是 <code>sk_buff</code> 链表还要求：每个节点必须能够<strong>很快的</strong>找到整个链表的头节点。为了实现这个要求，一个额外的数据结构 <code>sk_buff_head</code> 被添加到链表的头部，作为一个空节点：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff_head</span> &#123;</span></span><br><span class="line"><span class="comment">/* These two members must be first. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span>*<span class="title">next</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span>*<span class="title">prev</span>;</span></span><br><span class="line"></span><br><span class="line">__u32qlen;      <span class="comment">// 表示链表中的节点数，当前的sk_buff链上包含多少个skb</span></span><br><span class="line"><span class="type">spinlock_t</span>lock;  <span class="comment">// 加锁，防止对表的并发访问</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>sk_buff</code> 和 <code>sk_buff_head</code> 开始的两个字段是相同的，都是 <code>next</code> 和 <code>prev</code> 指针。即使 <code>sk_buff_head</code> 比 <code>sk_buff</code> 更轻量化，也允许这两种结构在链表中共存。另外，可以使用相同函数来操作 <code>sk_buff</code> 和 <code>sk_buff_head</code>。</p><p>为了实现通过每个节点都能快速找到链表头，每个节点都会包含一个指向链表中唯一的 <code>sk_buff_head</code> 的指针（<code>list</code>）。</p><p><img src="https://s2.loli.net/2024/04/03/QhEpcwg6iYrXJHk.png" alt="List of sk_buff elements"></p><p>下面是 layout 字段的详细解释：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> &#123;</span></span><br><span class="line"><span class="comment">/* These two members must be first. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span>*<span class="title">next</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span>*<span class="title">prev</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock</span>*<span class="title">sk</span>;</span>       <span class="comment">// 表示从属于那个socket，主要是被4层用到。  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>len,  <span class="comment">// 表示在 buffer 中数据区域的大小, 值会随着 buffer 在各层间传递而改变</span></span><br><span class="line">data_len;       <span class="comment">// 和 len 不同的是，data_len 只记录分段中的数据大小</span></span><br><span class="line">__u16mac_len,    <span class="comment">// MAC 头部的长度</span></span><br><span class="line">hdr_len;        <span class="comment">// header len</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>(*destructor)(<span class="keyword">struct</span> sk_buff *skb);  <span class="comment">// skb的析构函数，一般都是设置为sock_rfree或者sock_wfree</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">/* These elements must be at the end, see alloc_skb() for details.  */</span></span><br><span class="line"><span class="type">sk_buff_data_t</span>tail;</span><br><span class="line"><span class="type">sk_buff_data_t</span>end;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span>*head,</span><br><span class="line">*data;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>truesize; <span class="comment">// 表示整个skb的大小, 包括skb本身以及数据, 也就是 len+sizeof(struct sk_buff) </span></span><br><span class="line"><span class="type">atomic_t</span>users;  <span class="comment">// sk_buff 的引用计数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>head</code> 、<code>end</code> 、<code>data</code> 和 <code>tail</code> 这 4个指针用来表示 buffer 中数据域的边界。当每一层为了任务而准备 buffer 时，为了协议头或数据，可能会分配更多的空间。 <code>head</code> 和 <code>end</code> 指向了 buffer 被分配的内存区域的开始和结束， <code>data</code> 和 <code>tail</code> 指向真实数据的开始和结束。</p><p><img src="https://s2.loli.net/2024/04/03/uaKsCnXPf6Tyk75.png" alt="head/end versus data/tail pointers"></p><p>每一层能够在 <code>head</code> 和 <code>data</code> 之间的区域填充协议头，或者在 <code>tail</code> 和 <code>end</code> 之间的区域填充新的数据。</p><h1 id="general-fields" tabindex="-1">General Fields</h1><p>在 <code>sk_buff</code> 中存在一些通用目的的字段，这些字段没有与特定的内核功能绑定：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> &#123;</span></span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">skb_timeval</span><span class="title">tstamp</span>;</span>  <span class="comment">// 时间戳，表示何时被接收或有时表示包预定的传输时间</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_device</span>*<span class="title">dev</span>;</span>      <span class="comment">// 描述一个网络设备，之后会专门分析</span></span><br><span class="line"></span><br><span class="line"><span class="type">sk_buff_data_t</span>transport_header;  <span class="comment">// L4 协议栈的协议头</span></span><br><span class="line"><span class="type">sk_buff_data_t</span>network_header;    <span class="comment">// L3 协议栈的协议头</span></span><br><span class="line"><span class="type">sk_buff_data_t</span>mac_header;        <span class="comment">// L2 协议栈的协议头</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">dst_entry</span>*<span class="title">dst</span>;</span>  <span class="comment">// 由路由子系统使用，据说数据结构比较复杂</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This is the control buffer. It is free to use for every</span></span><br><span class="line"><span class="comment"> * layer. Please put your private variables there. If you</span></span><br><span class="line"><span class="comment"> * want to keep them across layers you have to do a skb_clone()</span></span><br><span class="line"><span class="comment"> * first. This is owned by whoever has the skb queued ATM.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">char</span>cb[<span class="number">48</span>];  <span class="comment">// control buffer, 后面详细分析</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 校验相关</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">__wsumcsum;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">__u16csum_start;</span><br><span class="line">__u16csum_offset;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">__u32priority;  <span class="comment">// 优先级，主要用于QoS</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 一些标识位</span></span><br><span class="line">kmemcheck_bitfield_begin(flags1);</span><br><span class="line">__u8local_df:<span class="number">1</span>,  <span class="comment">// 是否可以本地切片的标志</span></span><br><span class="line">cloned:<span class="number">1</span>,     <span class="comment">// 设置后表示此结构是另一个sk_buff缓冲区的克隆</span></span><br><span class="line">ip_summed:<span class="number">2</span>,  <span class="comment">// 这个表示校验相关的一个标记,表示硬件驱动是否为我们已经进行了校验</span></span><br><span class="line">nohdr:<span class="number">1</span>,      <span class="comment">// 这个域如果为1,则说明这个skb的头域指针已经分配完毕，因此这个时候计算头的长度只需要head和data的差就可以了</span></span><br><span class="line">nfctinfo:<span class="number">3</span>;</span><br><span class="line">__u8pkt_type:<span class="number">3</span>,  <span class="comment">// 主要是表示数据包的类型，比如多播，单播，回环等等，可在 include/linux/if_packet.h 中查看</span></span><br><span class="line">fclone:<span class="number">2</span>,        <span class="comment">// 这个域是一个clone标记，主要是在fast clone中被设置</span></span><br><span class="line">ipvs_property:<span class="number">1</span>, <span class="comment">// ipvs 相关</span></span><br><span class="line">peeked:<span class="number">1</span>,        <span class="comment">// udp 相关，表示只是查看数据</span></span><br><span class="line">nf_trace:<span class="number">1</span>;      <span class="comment">// netfilter 相关</span></span><br><span class="line">kmemcheck_bitfield_end(flags1);</span><br><span class="line">  </span><br><span class="line">__be16protocol;  <span class="comment">// 从 L2 处的网卡设备驱动程序的角度来看，在更高层次上使用的协议，完整列表可在 include/linux/if_ether.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>transport_header</code>、<code>network_header</code> 和 <code>mac_header</code> 分别为 L4 、L3 和 L2 的协议头。和之前版本比较有了变化，不再是联合体，使用更加方便了，Linux给出了很方便的函数直接定位到各层的头部。下图是2.4版本的，只是说明了数据包在不同协议层移动时 <code>data</code> 指针的处理。</p><ul><li>当接收到数据包时，负责处理第 n 层协议头的函数从第 n-1 层接收一个 buffer，其中<code>skb-&gt;data</code> 指向第 n 层协议头的开头。</li><li>处理第 n 层的函数会为此层初始化适当的指针（例如，L3 的处理函数会为 <code>skb-&gt;nh</code> 赋值）以保留 <code>skb-&gt;data</code> 字段，因为当 <code>skb-&gt;data</code> 被赋值为 buffer 内的其他偏移量时，该指针的内容将在下一层的处理过程中丢失。</li><li>该函数完成第 n 层的处理，并在将数据包传递到第 n+1 层处理程序之前，更新 <code>skb-&gt;data</code> 使其指向第 n 层协议头的末尾（即第 n+1 层协议头的开始位置）</li></ul><p><img src="https://s2.loli.net/2024/04/03/bOusozE75ICwhkR.png" alt="Header's pointer initializations while moving from layer two to layer three"></p><p>下面说一下 control buffer ，它用来存储一些私有信息，由各层维护以供内部使用。它是在 <code>sk_buff</code> 结构中静态分配的（当前大小为40个字节），并且足够大以容纳每一层所需的任何私有数据。在每一层的代码中，访问都是通过宏进行的，以使代码更具可读性。例如，TCP使用该空间存储 <code>tcp_skb_cb</code> 数据结构，该数据结构在 <code>include/net/tcp.h</code> 中定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcp_skb_cb</span> &#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">__u32seq;<span class="comment">/* Starting sequence number*/</span></span><br><span class="line">__u32end_seq;<span class="comment">/* SEQ + FIN + SYN + datalen*/</span></span><br><span class="line">__u8tcp_flags;<span class="comment">/* TCP header flags. (tcp[13])*/</span></span><br><span class="line">__u32ack_seq;<span class="comment">/* Sequence number ACK&#x27;d*/</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这是 TCP 代码访问结构的宏，宏仅由一个指针转换组成：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TCP_SKB_CB(__skb)((struct tcp_skb_cb *)&amp;((__skb)-&gt;cb[0]))</span></span><br></pre></td></tr></table></figure><p>这是一个示例，其中 TCP 模块在收到分段后填写 <code>cb</code> 结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">tcp_v4_fill_cb</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb, <span class="type">const</span> <span class="keyword">struct</span> iphdr *iph, <span class="type">const</span> <span class="keyword">struct</span> tcphdr *th)</span> &#123;</span><br><span class="line">    TCP_SKB_CB(skb)-&gt;seq = ntohl(th-&gt;seq);</span><br><span class="line">    TCP_SKB_CB(skb)-&gt;end_seq = (TCP_SKB_CB(skb)-&gt;seq + th-&gt;syn + th-&gt;fin + skb-&gt;len - th-&gt;doff * <span class="number">4</span>);</span><br><span class="line">    TCP_SKB_CB(skb)-&gt;ack_seq = ntohl(th-&gt;ack_seq);</span><br><span class="line">    TCP_SKB_CB(skb)-&gt;tcp_flags = tcp_flag_byte(th);</span><br><span class="line">    TCP_SKB_CB(skb)-&gt;tcp_tw_isn = <span class="number">0</span>;</span><br><span class="line">    TCP_SKB_CB(skb)-&gt;ip_dsfield = ipv4_get_dsfield(iph);</span><br><span class="line">    TCP_SKB_CB(skb)-&gt;sacked  = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="feature-specific-fields" tabindex="-1">Feature-Specific Fields</h1><p>Linux内核是模块化的，允许你选择要包括的内容和要忽略的内容。因此，只有在编译内核时开启支持像 Netfilter 或 QoS 之类的特定功能的情况下，某些字段才会包含在 <code>sk_buff</code> 数据结构中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> &#123;</span></span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_NF_CONNTRACK) || defined(CONFIG_NF_CONNTRACK_MODULE)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nf_conntrack</span>*<span class="title">nfct</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span>*<span class="title">nfct_reasm</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_BRIDGE_NETFILTER</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nf_bridge_info</span>*<span class="title">nf_bridge</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_NET_SCHED</span></span><br><span class="line">__u16tc_index;<span class="comment">/* traffic control index */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_NET_CLS_ACT</span></span><br><span class="line">__u16tc_verd;<span class="comment">/* traffic control verdict */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="management-functions" tabindex="-1">Management Functions</h1><p>内核提供了许多很简短的简单函数来操纵 <code>sk_buff</code> 节点或链表。如果查看文件 <code>include/linux/skbuff.h</code> 和 <code>net/core/skbuff.c</code>，你会发现几乎所有功能都有两个版本，名称分别为 <code>do_something</code> 和 <code>__do_something</code>。通常，第一个是包装函数，它在对第二个调用的周围添加了额外的健全性检查或锁定机制。内部 <code>__do_something</code> 函数通常不直接调用。该规则的例外通常是编码不良的函数，这些函数最终将被修复。</p><h2 id="%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D" tabindex="-1" id="内存分配">内存分配</h2><h3 id="alloc_skb" tabindex="-1" id="alloc-skb">alloc_skb</h3><p><code>alloc_skb</code> 是分配缓冲区的主要函数，在 <code>net/core/skbuff.c</code> 中定义。</p><p><code>__alloc_skb</code> 分配缓冲区和一个 <code>sk_buff</code> 结构，这个函数起始可以看作三部分：</p><ul><li>第一部分是分配内存，由于数据缓冲区和 <code>sk_buff</code> 自身是两个不同的结构，所以创建单个缓冲区涉及两个内存分配<ul><li>调用函数 <code>kmem_cache_alloc</code> 从缓存中获取 <code>sk_buff</code> 数据结构</li><li>调用 <code>kmalloc</code> 获取数据缓冲区，而 <code>kmalloc</code> 也会使用缓存的内存（如果可用）</li></ul></li><li>第二部分是初始化分配的 skb 的相关域</li><li>第三部分是处理 <code>fclone</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *__<span class="title">alloc_skb</span>(<span class="title">unsigned</span> <span class="title">int</span> <span class="title">size</span>, <span class="title">gfp_t</span> <span class="title">gfp_mask</span>, <span class="title">int</span> <span class="title">fclone</span>, <span class="title">int</span> <span class="title">node</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">cache</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">skb_shared_info</span> *<span class="title">shinfo</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>;</span></span><br><span class="line">u8 *data;</span><br><span class="line"></span><br><span class="line">cache = fclone ? skbuff_fclone_cache : skbuff_head_cache;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Get the HEAD */</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 申请 sk_buff 数据结构的内存</span></span><br><span class="line">skb = kmem_cache_alloc_node(cache, gfp_mask &amp; ~__GFP_DMA, node);</span><br><span class="line"><span class="keyword">if</span> (!skb)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">prefetchw(skb);</span><br><span class="line"></span><br><span class="line">size = SKB_DATA_ALIGN(size);</span><br><span class="line">  <span class="comment">// 申请数据区域的内存</span></span><br><span class="line">data = kmalloc_node_track_caller(size + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> skb_shared_info), gfp_mask, node);</span><br><span class="line"><span class="keyword">if</span> (!data)</span><br><span class="line"><span class="keyword">goto</span> nodata;</span><br><span class="line">prefetchw(data + size);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Only clear those fields we need to clear, not those that we will</span></span><br><span class="line"><span class="comment"> * actually initialise below. Hence, don&#x27;t put any more fields after</span></span><br><span class="line"><span class="comment"> * the tail pointer in struct sk_buff!</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">memset</span>(skb, <span class="number">0</span>, offsetof(<span class="keyword">struct</span> sk_buff, tail));</span><br><span class="line">skb-&gt;truesize = size + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sk_buff);</span><br><span class="line"><span class="type">atomic_set</span>(&amp;skb-&gt;users, <span class="number">1</span>);</span><br><span class="line">skb-&gt;head = data;</span><br><span class="line">skb-&gt;data = data;</span><br><span class="line">skb_reset_tail_pointer(skb);</span><br><span class="line">skb-&gt;end = skb-&gt;tail + size;</span><br><span class="line">kmemcheck_annotate_bitfield(skb, flags1);</span><br><span class="line">kmemcheck_annotate_bitfield(skb, flags2);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> NET_SKBUFF_DATA_USES_OFFSET</span></span><br><span class="line">skb-&gt;mac_header = ~<span class="number">0U</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* make sure we initialize shinfo sequentially */</span></span><br><span class="line">shinfo = skb_shinfo(skb);</span><br><span class="line"><span class="built_in">memset</span>(shinfo, <span class="number">0</span>, offsetof(<span class="keyword">struct</span> skb_shared_info, dataref));</span><br><span class="line"><span class="type">atomic_set</span>(&amp;shinfo-&gt;dataref, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (fclone) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">child</span> =</span> skb + <span class="number">1</span>;</span><br><span class="line"><span class="type">atomic_t</span> *fclone_ref = (<span class="type">atomic_t</span> *) (child + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">kmemcheck_annotate_bitfield(child, flags1);</span><br><span class="line">kmemcheck_annotate_bitfield(child, flags2);</span><br><span class="line">skb-&gt;fclone = SKB_FCLONE_ORIG;</span><br><span class="line"><span class="type">atomic_set</span>(fclone_ref, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">child-&gt;fclone = SKB_FCLONE_UNAVAILABLE;</span><br><span class="line">&#125;</span><br><span class="line">out:</span><br><span class="line"><span class="keyword">return</span> skb;</span><br><span class="line">nodata:</span><br><span class="line">kmem_cache_free(cache, skb);</span><br><span class="line">skb = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在调用 <code>kmalloc</code> 之前，使用宏 <code>SKB_DATA_ALIGN</code> 调整了大小参数以强制对齐。返回之前，该函数将初始化结构体中的一些参数，从而产生下图所示的最终结果：</p><p><img src="https://s2.loli.net/2024/04/03/Vbf43YJQFZXHLDK.png" alt="alloc_skb function"></p><p>在图右侧存储块的底部，可以看到为了强制对齐而引入的 Padding 区域。 <code>skb_shared_info</code> 块主要用于处理 IP 的分片（IP 协议根据 MTU 和 MSS 对数据包进行的分片传输）。</p><p><code>__alloc_skb</code> 函数可以叫做 Fast SKB cloning 函数，这个函数存在的主要原因是，以前我们每次 <code>skb_clone</code> 一个 skb 的时候，都是要调用 <code>kmem_cache_alloc</code> 从 cache 中 alloc 一块新的内存。而现在当我们拥有了 fast clone 之后，通过调用 <code>alloc_skb_fclone</code> 函数来分配一块大于 <code>sizeof(struct sk_buff)</code> 的内存，也就是在这次请求的 skb 的下方多申请了一些内存，然后返回的时候设置返回的 skb 的 <code>fclone</code> 标记为 <code>SKB_FCLONE_ORIG</code>，而多申请的那块内存的 <code>sk_buff</code> 的 fclone 为 <code>SKB_FCLONE_UNAVAILABLE</code>，这样当我们调用 <code>skb_clone</code> 克隆这个 skb 的时候看到 fclone 的标记就可以直接将 skb 的指针+1,而不需要从 cache 中取了。这样的话节省了一次内存存取，提高了 clone 的效率，不过调用 flcone 一般都是我们确定接下来这个 skb 会被 clone 很多次。</p><p>更详细的 fclone 的介绍可以看<a href="http://lwn.net/Articles/140552/">这里</a>。</p><h3 id="dev_alloc_skb" tabindex="-1" id="dev-alloc-skb">dev_alloc_skb</h3><p><code>dev_alloc_skb()</code> 也是一个缓冲区分配函数，它主要被设备驱动接收数据包时使用，通常用在中断上下文中。这是一个 <code>alloc_skb()</code> 的包装函数，它会在请求分配的大小上增加 <code>NET_SKB_PAD</code> 字节的空间以优化缓冲区的读写效率，它的分配要求使用 <code>gfp_mask</code>，为调用函数指定。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// allocate an skbuff for receiving</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *__<span class="title">dev_alloc_skb</span>(<span class="title">unsigned</span> <span class="title">int</span> <span class="title">length</span>, <span class="title">gfp_t</span> <span class="title">gfp_mask</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span> =</span> alloc_skb(length + NET_SKB_PAD, gfp_mask);</span><br><span class="line"><span class="keyword">if</span> (likely(skb))</span><br><span class="line">skb_reserve(skb, NET_SKB_PAD);</span><br><span class="line"><span class="keyword">return</span> skb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="%E5%86%85%E5%AD%98%E9%87%8A%E6%94%BE" tabindex="-1" id="内存释放">内存释放</h2><h3 id="kfree_skb" tabindex="-1" id="kfree-skb">kfree_skb</h3><p><code>kfree_skb</code> 只有 <code>skb-&gt;users</code> 计数器为1时才释放，这里主要是判断一个引用标记位 <code>users</code>，将它减一，如果大于0则直接返回，否则释放 skb。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">kfree_skb</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (unlikely(!skb))</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (likely(<span class="type">atomic_read</span>(&amp;skb-&gt;users) == <span class="number">1</span>))</span><br><span class="line">smp_rmb();</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (likely(!atomic_dec_and_test(&amp;skb-&gt;users)))</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">trace_kfree_skb(skb, __builtin_return_address(<span class="number">0</span>));</span><br><span class="line">__kfree_skb(skb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>kfree_skb</code> 仅在 <code>skb-&gt;users</code> 计数器为1时（没有缓冲区的用户时）才释放缓冲区。 否则，该函数只会使该计数器递减。因此，如果一个缓冲区有三个用户，则只有当调用第三次 <code>dev_kfree_skb</code> 或 <code>kfree_skb</code> 时才会真正释放内存。</p><p><img src="https://s2.loli.net/2024/04/03/tfjp9dnZHoIiURN.png" alt="kfree_skb function"></p><h2 id="%E6%95%B0%E6%8D%AE%E4%BF%9D%E7%95%99%E5%92%8C%E5%AF%B9%E9%BD%90" tabindex="-1" id="数据保留和对齐">数据保留和对齐</h2><ul><li>skb_put：在数据域尾部追加一段空间</li><li>skb_push：在数据域的头部追加一段空间</li><li>skb_pull：将 <code>skb-&gt;data</code> 指针在数据域下移指定字节</li><li>skb_reserve：在 <code>sk_buff</code> 中 <code>skb-&gt;data</code> 之前的空间追加一段空间（在每层追加自己的协议头时常用到）</li></ul><p>下图为分别对 <code>sk_buff</code> 执行 <code>skb_put</code>(a)，<code>skb_push</code>(b)，<code>skb_pull</code>©，<code>skb_reserve</code>(d) 的前后对比：</p><p><img src="https://s2.loli.net/2024/04/03/e4bcOrAKzRG78gn.png" alt="Before and after: (a)skb_put, (b)skb_push, (c)skb_pull, and (d)skb_reserve"></p><h3 id="skb_put" tabindex="-1" id="skb-put">skb_put</h3><p>先来看 <code>__skb_put</code> 函数，可以看到它只是将 <code>tail</code> 指针移动 <code>len</code> 个位置，然后 <code>len</code> 也相应的增加 <code>len</code> 个大小。 以下均在 <code>/include/linux/skbuff.h</code> 中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">char</span> *__skb_put(<span class="keyword">struct</span> sk_buff *skb, <span class="type">unsigned</span> <span class="type">int</span> len)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *tmp = skb_tail_pointer(skb);</span><br><span class="line">SKB_LINEAR_ASSERT(skb);</span><br><span class="line">skb-&gt;tail += len;</span><br><span class="line">skb-&gt;len  += len;</span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="skb_push" tabindex="-1" id="skb-push">skb_push</h3><p><code>__skb_push</code> 是将 <code>data</code> 指针向上移动 <code>len</code> 个位置，对应的 <code>len</code> 肯定也是增加 <code>len</code> 大小。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">char</span> *__skb_push(<span class="keyword">struct</span> sk_buff *skb, <span class="type">unsigned</span> <span class="type">int</span> len)</span><br><span class="line">&#123;</span><br><span class="line">skb-&gt;data -= len;</span><br><span class="line">skb-&gt;len  += len;</span><br><span class="line"><span class="keyword">return</span> skb-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="skb_pull" tabindex="-1" id="skb-pull">skb_pull</h3><p><code>__skb_pull</code> 是将 <code>data</code> 指针向下移动 <code>len</code> 个位置，然后 <code>len</code> 减小 <code>len</code> 大小</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">char</span> *__skb_pull(<span class="keyword">struct</span> sk_buff *skb, <span class="type">unsigned</span> <span class="type">int</span> len)</span><br><span class="line">&#123;</span><br><span class="line">skb-&gt;len -= len;</span><br><span class="line">BUG_ON(skb-&gt;len &lt; skb-&gt;data_len);</span><br><span class="line"><span class="keyword">return</span> skb-&gt;data += len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="skb_reserve" tabindex="-1" id="skb-reserve">skb_reserve</h3><p><code>__skb_reserve</code> 是将整个数据区，也就是 <code>data</code> 以及 <code>tail</code> 指针一起向下移动 <code>len</code> 大小。<code>skb_reserve</code> 在缓冲区的头部保留一些空间，通常用于允许插入协议头或强制将数据在某个边界上对齐。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">skb_reserve</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">skb-&gt;data += len;</span><br><span class="line">skb-&gt;tail += len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，<code>skb_reserve</code> 函数实际上并没有将任何内容移入或移出数据缓冲区，它只是更新两个指针。</p><p>查看以太网网卡驱动程序的代码（比如: <code>drivers/net/ethernet/3com/3c59x.c</code> <code>vortex_rx</code> 函数），你能看到它们在将任何数据存储在他们刚刚分配的缓冲区中之前都会使用以下命令：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">skb_reserve(skb, <span class="number">2</span>);<span class="comment">/* Align IP on 16 byte boundaries */</span></span><br></pre></td></tr></table></figure><p>因为他们知道他们将要把协议头为 14 个字节的以太网帧复制到缓冲区中，所以参数 2 将缓冲区的 <code>head</code> 指针下移了 2 个字节。这将让紧跟在以太网头之后的 IP 头，从缓冲区的开头在 16 字节边界上对齐。</p><p><img src="https://s2.loli.net/2024/04/03/zU2VeWqCj6Ov4F7.png" alt="(a) before skb_reserve, (b) after skb_reserve, and (c) after copying the frame on the buffer"></p><p>下图展示了 <code>skb_reserve</code> 在数据从上到下传递（发送数据）时的作用（为下层协议在数据区的头部分配空间）：</p><p><img src="https://s2.loli.net/2024/04/03/IeoY4Ptam6xsbDw.png" alt="Buffer that is filled in while traversing the stack from the TCP layer down to the link layer"></p><ul><li>当要求 TCP 传输某些数据时，它会按照某些条件（TCP Max Segment Size(mss)，对分散收集 I/O 支持等）分配一个缓冲区。</li><li>TCP 在缓冲区的头部保留（通过调用 <code>skb_reserve</code>）足够的空间，以容纳所有层（TCP，IP，Link 层）的所有协议头。参数 <code>MAX_TCP_HEADER</code> 是所有级别的所有协议头的总和，并考虑到最坏的情况：因为 TCP 层不知道将使用哪种类型的接口进行传输，因此它为每个层保留最大的标头。它甚至考虑到多个 IP 协议头的可能性（因为当内核编译为支持 IP in IP 时，你可以拥有多个IP 协议头）。</li><li>TCP 的 payload （应用层传输的数据）被复制到缓冲区中。请注意上图只是个例子，TCP 的 payload 可以被不同地组织，例如可以将其存储为片段。</li><li>TCP 层添加它的协议头。</li><li>TCP 层将缓冲区移交给 IP 层，IP层也添加协议头。</li><li>IP 层将缓冲区移交给下一层，下一层也添加它的协议头。</li></ul><blockquote><p>请注意，当缓冲区在网络栈中向下移动时，每个协议会将 <code>skb-&gt;data</code> 指针向下移动，在其协议头中复制，并更新 <code>skb-&gt;len</code>。</p></blockquote><p><code>skb_push</code> 将一个数据块添加到缓冲区的开头，而 <code>skb_put</code> 将一个数据块添加到末尾。像 <code>skb_reserve</code> 一样，这些函数实际上并不会向缓冲区添加任何数据。他们只是将指针移到它的头或尾，数据填充应该由其他功能显式操作。<code>skb_pull</code> 通过将 <code>head</code> 指针向前移动来从缓冲区的头中删除数据块。</p><h3 id="skb_shared_info-%E7%BB%93%E6%9E%84%E4%BD%93-%26-skb_shinfo-%E5%87%BD%E6%95%B0" tabindex="-1" id="skb-shared-info-结构体-skb-shinfo-函数">skb_shared_info 结构体 &amp; skb_shinfo 函数</h3><p>在上面网卡驱动拷贝帧到缓冲区的例子中出现过 <code>skb_shared_info</code>。它是用来保留与数据域有关的其他信息。这个数据结构紧跟在标记数据域结束的 <code>end</code> 指针后面。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">skb_shared_info</span> &#123;</span></span><br><span class="line">    <span class="type">atomic_t</span>        dataref;  <span class="comment">// 代表数据域的用户数（数据域被引用的次数）</span></span><br><span class="line">    __u8            nr_frags;             <span class="comment">// 用于 ip fragmetation</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span>*<span class="title">frag_list</span>;</span>           <span class="comment">// 用于 ip fragmetation</span></span><br><span class="line">    <span class="type">skb_frag_t</span>    frags[MAX_SKB_FRAGS]; <span class="comment">// 用于 ip fragmetation</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>skb_is_nonlinear</code> 函数可用于检查缓冲区是否已分段，而 <code>skb_linearize</code> 函数可用于将多个片段合为单个缓冲区。</p><p><code>sk_buff</code> 中没有专门的指针指向 <code>skb_shared_info</code> 区域，<code>skb_shinfo</code> 函数就是方便得到指向 <code>skb_shared_info</code> 区域指针的函数:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> skb_shinfo(SKB)((struct skb_shared_info *)(skb_end_pointer(SKB)))</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">char</span> *<span class="title function_">skb_end_pointer</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> sk_buff *skb)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> skb-&gt;end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="%E5%85%8B%E9%9A%86%E5%92%8C%E6%8B%B7%E8%B4%9D" tabindex="-1" id="克隆和拷贝">克隆和拷贝</h2><h3 id="skb_clone" tabindex="-1" id="skb-clone">skb_clone</h3><p>当相同的缓冲区需要由不同的消费者处理，并且他们可能更改 <code>sk_buff</code> 结构中的内容时，为了提高效率，<strong>内核并没有克隆缓冲区的结构和数据域</strong>，而是仅复制 <code>sk_buff</code> 的结构，并使用引用计数进行操作，以避免过早释放共享数据块。<code>skb_clone</code> 函数负责拷贝一个 buffer。使用克隆的一种情况是，需要将入口数据包分发给多个接收者，例如协议处理程序和一个或多个网络分接头（Network taps）。</p><p><code>sk_buff</code> 克隆不会链接到任何链表，也没有引用套接字所有者。克隆和原始缓冲区中的 <code>skb-&gt;cloned</code> 字段均设置为1。在克隆中将 <code>skb-&gt;users</code> 设置为1，以便第一次尝试删除它（被克隆的 <code>sk_buff</code>）时会成功，并且数据域的引用数（<code>dataref</code>）递增（因为现在有一个新的 <code>sk_buff</code> 指向了）。</p><p><code>skb_clone</code> 会调用 <code>__skb_clone</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *__<span class="title">skb_clone</span>(<span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">n</span>, <span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>) </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> C(x) n-&gt;x = skb-&gt;x </span></span><br><span class="line"><span class="comment">// 定义的宏，如果 x 是普通变量则是值赋值</span></span><br><span class="line"><span class="comment">// 如果 x 是指针，则是指向同一块区域</span></span><br><span class="line"></span><br><span class="line">n-&gt;next = n-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">n-&gt;sk = <span class="literal">NULL</span>;</span><br><span class="line">__copy_skb_header(n, skb);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">n-&gt;destructor = <span class="literal">NULL</span>;</span><br><span class="line">C(tail);</span><br><span class="line">C(end);</span><br><span class="line">C(head);</span><br><span class="line">C(head_frag);</span><br><span class="line">C(data);    <span class="comment">// data 是一个指针, 所以没有克隆数据域，只是指向了数据域的内存地址</span></span><br><span class="line">C(truesize);</span><br><span class="line">refcount_set(&amp;n-&gt;users, <span class="number">1</span>); <span class="comment">//设置克隆的 sk_buff 的用户数为1</span></span><br><span class="line"><span class="type">atomic_inc</span>(&amp;(skb_shinfo(skb)-&gt;dataref)); <span class="comment">//增加数据域的引用次数</span></span><br><span class="line">skb-&gt;cloned = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> C</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下图为一个被分段（一个缓冲区，其中一些数据存储在与 <code>frags</code> 数组链接的数据片段中）了的缓冲区克隆的例子:</p><p><img src="https://s2.loli.net/2024/04/03/Xy96ZWPxKGum32C.png" alt="skb_clone function"></p><h3 id="pskb_copy-%E4%B8%8E-skb_copy" tabindex="-1" id="pskb-copy-与-skb-copy">pskb_copy 与 skb_copy</h3><p>当缓冲区被克隆时，无法修改数据块的内容。这意味着代码无需做同步保证即可访问数据。但是，当一个函数不仅需要修改 <code>sk_buff</code> 结构的内容，还需要修改数据域时，就必须要克隆数据域了。如果真要修改数据域，开发者也有两个选项可用：</p><ol><li>当开发者知道自己仅仅需要修改的数据在 <code>skb-&gt;start</code> 和 <code>skb-&gt;end</code> 的区域时，开发者可以使用 <code>pskb_copy</code> 方法只克隆那个区域。</li><li>当开发者认为自己或许也需要修改分段数据域时，也就是 <code>skb_shared_info</code>，就必须使用 <code>skb_copy</code>。</li></ol><p><code>pskb_copy</code> 和 <code>skb_copy</code> 的不同如下图中的(a)和(b):</p><p><img src="https://s2.loli.net/2024/04/03/RenJrMwbf6uNxZI.png" alt="(a) pskb_copy function and (b) skb_copy function"></p><p>在决定克隆或复制缓冲区时，每个子系统的程序员都无法预料其他内核组件（或其子系统的其他用户）是否需要该缓冲区中的原始信息。内核是非常模块化的，并且以非常动态和不可预测的方式进行更改，因此每个子系统都不知道其他子系统可以使用缓冲区做什么。因此，每个子系统的程序员只需跟踪他们对缓冲区所做的任何修改，并注意<strong>在修改任何内容之前先进行复制，以防内核的其他部分需要原始信息</strong>。</p><h2 id="%E9%98%9F%E5%88%97%E7%AE%A1%E7%90%86%E5%87%BD%E6%95%B0" tabindex="-1" id="队列管理函数">队列管理函数</h2><p>有一些函数用来维护 <code>sk_buff</code> 双向链表（也可以称为队列 queue）中的节点。下面是一些常用的功能函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// skb_queue_head - queue a buffer at the list head</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">skb_queue_head</span><span class="params">(<span class="keyword">struct</span> sk_buff_head *<span class="built_in">list</span>, <span class="keyword">struct</span> sk_buff *newsk)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"></span><br><span class="line">spin_lock_irqsave(&amp;<span class="built_in">list</span>-&gt;lock, flags);</span><br><span class="line">__skb_queue_head(<span class="built_in">list</span>, newsk);</span><br><span class="line">spin_unlock_irqrestore(&amp;<span class="built_in">list</span>-&gt;lock, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// skb_queue_tail - queue a buffer at the list tail</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">skb_queue_tail</span><span class="params">(<span class="keyword">struct</span> sk_buff_head *<span class="built_in">list</span>, <span class="keyword">struct</span> sk_buff *newsk)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"></span><br><span class="line">spin_lock_irqsave(&amp;<span class="built_in">list</span>-&gt;lock, flags);</span><br><span class="line">__skb_queue_tail(<span class="built_in">list</span>, newsk);</span><br><span class="line">spin_unlock_irqrestore(&amp;<span class="built_in">list</span>-&gt;lock, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// skb_dequeue - remove from the head of the queue</span></span><br><span class="line"><span class="keyword">struct</span> sk_buff *<span class="title function_">skb_dequeue</span><span class="params">(<span class="keyword">struct</span> sk_buff_head *<span class="built_in">list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">result</span>;</span></span><br><span class="line"></span><br><span class="line">spin_lock_irqsave(&amp;<span class="built_in">list</span>-&gt;lock, flags);</span><br><span class="line">result = __skb_dequeue(<span class="built_in">list</span>);</span><br><span class="line">spin_unlock_irqrestore(&amp;<span class="built_in">list</span>-&gt;lock, flags);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// skb_dequeue_tail - remove from the tail of the queue</span></span><br><span class="line"><span class="keyword">struct</span> sk_buff *<span class="title function_">skb_dequeue_tail</span><span class="params">(<span class="keyword">struct</span> sk_buff_head *<span class="built_in">list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">result</span>;</span></span><br><span class="line"></span><br><span class="line">spin_lock_irqsave(&amp;<span class="built_in">list</span>-&gt;lock, flags);</span><br><span class="line">result = __skb_dequeue_tail(<span class="built_in">list</span>);</span><br><span class="line">spin_unlock_irqrestore(&amp;<span class="built_in">list</span>-&gt;lock, flags);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// skb_queue_purge - empty a list</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">skb_queue_purge</span><span class="params">(<span class="keyword">struct</span> sk_buff_head *<span class="built_in">list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>;</span></span><br><span class="line"><span class="keyword">while</span> ((skb = skb_dequeue(<span class="built_in">list</span>)) != <span class="literal">NULL</span>)</span><br><span class="line">kfree_skb(skb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>操作队列的所有函数都必须保证是原子操作。也就是说，它们必须获取 <code>sk_buff_head</code> 结构提供的队列自旋锁。否则，它们可能会被异步事件中断，这些异步事件会使队列中的元素入队或出队，例如到期计时器调用的函数会导致争用条件。</p><h1 id="%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99" tabindex="-1">参考资料</h1><ul><li><a href="https://wiki.linuxfoundation.org/networking/sk_buff">Linux Foundation Wiki: sk_buff</a></li><li>Understanding Linux Network Internals: Section 2.1. The Socket Buffer: sk_buff Structure</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文转载自 &lt;a href=&quot;https://houmin.cc/&quot;&gt;houmin.cc&lt;/a&gt;，原文已被删除，但因为之前阅读此文感觉说明较为清楚（后来查了下主要参考的是 Understanding Linux Network Internals 这本书），因此为方便今后查看，从 &lt;a href=&quot;https://web.archive.org/web/20220529013919/https://houmin.cc/posts/bec07334/&quot;&gt;wayback machine&lt;/a&gt; 找到并转载了这篇文章。文章内容可能有补充修正。&lt;/p&gt;
&lt;p&gt;在 Linux 内核的网络代码中，&lt;code&gt;sk_buff&lt;/code&gt; 或许是最重要的数据结构，用来表示已接收或将要传输的数据。 &lt;code&gt;sk_buff&lt;/code&gt; 定义在 &lt;code&gt;include/linux/skbuff.h&lt;/code&gt; 中，它由许多变量组成，目标就是满足所有网络协议的需要。随着数据包在内核协议栈不同层次传递时，Linux 内核不是通过层与层之间的数据拷贝，而是通过追加头信息的方式，这即是 &lt;code&gt;sk_buff&lt;/code&gt; 被使用的典型场景：在不同网络协议层之间移动，通过添加数据头的形式传递数据。本文分析采用的是 2.6.35 版本内核。&lt;/p&gt;</summary>
    
    
    
    <category term="内核" scheme="https://universesaurora.top/categories/%E5%86%85%E6%A0%B8/"/>
    
    
    <category term="网络" scheme="https://universesaurora.top/tags/%E7%BD%91%E7%BB%9C/"/>
    
    <category term="内核" scheme="https://universesaurora.top/tags/%E5%86%85%E6%A0%B8/"/>
    
    <category term="Linux" scheme="https://universesaurora.top/tags/Linux/"/>
    
    <category term="sk_buff" scheme="https://universesaurora.top/tags/sk-buff/"/>
    
  </entry>
  
  <entry>
    <title>CFS调度器、权重、优先级与虚拟时钟</title>
    <link href="https://universesaurora.top/2023/04/20/cfs_weight_nice/"/>
    <id>https://universesaurora.top/2023/04/20/cfs_weight_nice/</id>
    <published>2023-04-20T13:47:32.000Z</published>
    <updated>2023-04-21T02:25:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>盘一盘在学习 CFS 调度器过程中的一些感想。</p><article class="message message-immersive is-primary"><div class="message-body"><i class="fas fa-drafting-compass mr-2"></i>施工中！！！<p>咕咕咕！</p></div></article><span id="more"></span>]]></content>
    
    
    <summary type="html">&lt;p&gt;盘一盘在学习 CFS 调度器过程中的一些感想。&lt;/p&gt;
&lt;article class=&quot;message message-immersive is-primary&quot;&gt;
&lt;div class=&quot;message-body&quot;&gt;
&lt;i class=&quot;fas fa-drafting-compass mr-2&quot;&gt;&lt;/i&gt;
施工中！！！
&lt;p&gt;咕咕咕！&lt;/p&gt;
&lt;/div&gt;
&lt;/article&gt;</summary>
    
    
    
    <category term="内核" scheme="https://universesaurora.top/categories/%E5%86%85%E6%A0%B8/"/>
    
    
    <category term="内核" scheme="https://universesaurora.top/tags/%E5%86%85%E6%A0%B8/"/>
    
    <category term="调度器" scheme="https://universesaurora.top/tags/%E8%B0%83%E5%BA%A6%E5%99%A8/"/>
    
    <category term="Linux" scheme="https://universesaurora.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>nvdimm 技术与编程模型概览</title>
    <link href="https://universesaurora.top/2022/07/18/nvdimm_intro/"/>
    <id>https://universesaurora.top/2022/07/18/nvdimm_intro/</id>
    <published>2022-07-18T08:45:16.000Z</published>
    <updated>2023-04-18T05:49:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>nvdimm，即非易失性双列直插式内存模块（non-volatile DIMM），相对于传统的易失性内存，nvdimm 在断电后其中的内容也不会消失。</p><article class="message message-immersive is-primary"><div class="message-body"><i class="fas fa-drafting-compass mr-2"></i>施工中！！！<p>咕咕咕！</p></div></article><span id="more"></span><p>定义于 ACPI（NFIT），UEFI（BTT），带外通信使用 DSM。</p><p>交错本来是传统易失性内存中的一个概念。N 代表数字，和 N 通道不是一个概念，只有交错后才能叫做 N 路.</p><h2 id="%E7%90%86%E8%AE%BA" tabindex="-1" id="理论">理论</h2><p>本节参考 <a href="https://www.usenix.org/system/files/login/articles/08_rudoff_040-045_final.pdf">Programming Models for Emerging Non-Volatile Memory Technologies</a> 和 <a href="https://www.usenix.org/system/files/login/articles/login_summer17_07_rudoff.pdf">Persistent Memory Programming</a> 这两篇文章，讲述几种理论上的持久化内存编程模型和有关的问题。文章中的 NVM 泛指各种非易失性内存设备。</p><h3 id="%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B" tabindex="-1" id="编程模型">编程模型</h3><p>理论上有很多种可能的持久化内存编程模型，这里主要聚焦在最相关的的四种。NVM Block Mode 和 NVM File Mode 代表的是过去最常用的储存接口，PM Volume Mode 和 PM File Mode 则主要针对持久内存。</p><h4 id="nvm-block-mode" tabindex="-1" id="NVM-Block-Mode">NVM Block Mode</h4><p><img src="https://s2.loli.net/2024/04/03/iGZfToYMF36Kqhn.png" alt="NVM Block Mode"></p><p>上图表示了常见软件栈的一部分，红线表示了 NVM Block Mode 的接口，这里的接口指的是块读写接口。可以看到，在这个模型中驱动向文件系统等内核模块或直接向应用程序（如直接打开 /dev/sda1 设备）提供了传统块读写接口。为了使这种传统的接口更好的支持非易失性内存设备，可能需要对它进行功能上的扩展，以得到 I/O 性能的优化，例如一些原子操作的支持，向应用程序提供非易失性内存的某些属性等。通过将这种扩展标准化，能够为软件编写者提供一个更有效的生态系统来开发非易失性内存感知的应用程序。</p><h4 id="nvm-file-mode" tabindex="-1" id="NVM-File-Mode">NVM File Mode</h4><p><img src="https://s2.loli.net/2024/04/03/fNTQLtgeyE23s5r.png" alt="NVM File Mode"></p><p>NVM File Mode 模式中主要关注的是应用程序和文件系统间的文件接口。和 NVM Block Mode 一样，为了更好的支持非易失性内存设备，文件接口可能需要进行一些扩展。</p><p>例如，MySQL 数据库的双重写入技术防止数据库在遇到电源故障等情况时，储存在文件中的数据表中的页面只被部分写入。如果数据库能够感知到硬件能够保证对于一定大小的页面写入不会因为系统中断导致撕裂，就可以避免双重写入的过程。为应用程序提供一个获取 powerfail write atomicity 的接口可以让程序自己决定合适的行为。</p><h4 id="pm-volume-mode" tabindex="-1" id="PM-Volume-Mode">PM Volume Mode</h4><p><img src="https://s2.loli.net/2024/04/03/wITnqpfKtZxsm9R.png" alt="PM Volume Mode"></p><p>如上图，在 PM Volume Mode 中，非易失性内存设备（NVM devices）是支持 PM 的，意味着设备可以通过处理器的 load 和 store 指令直接操作。尽管任何储存元件都可能通过一种处理器可以直接从中加载数据的方式连接到系统，但 NAND Flash 等技术会使处理器在加载时暂停，使得这种连接方式难以实现。更先进的非易失性内存设备和缓存技术使得这种方式成为可能。</p><p>在 PM Volume 模式下，内核组件可以直接访问持久内存区域。上图中红线标出的接口使得能够感知 PM 的内核模块和 NVM 驱动进行通信，这是为了让内核模块获取持久内存的物理地址范围。在这之后他就不再需要调用 NVM 驱动，而是直接通过地址访问持久内存。</p><h4 id="pm-file-mode" tabindex="-1" id="PM-File-Mode">PM File Mode</h4><p><img src="https://s2.loli.net/2024/04/03/dxfROiUTYDJNjoI.png" alt="PM File Mode"></p><p>PM File Mode 看起来和 NVM File Mode 有些相似，但不同的是这里的文件系统是感知 PM 的，可以看到这种文件系统就是通过上文的 PM Volume Mode 模型实现的。</p><p>感知 PM 的文件系统提供了所有传统文件系统会提供的文件接口，实际上它通常通过在已有的文件系统的基础上扩展 PM 感知能力来实现的。这种模式最主要的特点是，在使用 mmap 将一个文件 map 到内存空间时，应用程序可以绕过内核直接 load/store 持久内存，而在传统文件系统中文件 mmap 到内存中时需要使用 page cache 机制。</p><h3 id="persistent-memory" tabindex="-1" id="Persistent-Memory">Persistent Memory</h3><p>与 NVM Block Mode 和 NVM File Mode 的增量式改进不同，PM 的改进更具有颠覆性。正如 CPU 从提高频率到提高核心数量的转变时应用需要重新思考他们的算法并转向多线程编程一样，PM 结合了持久性和无需先进行块 I/O 的能力，它使我们重新思考数据结构以什么形式持久的储存。</p><h4 id="%E7%94%B3%E8%AF%B7-pm-%E5%86%85%E5%AD%98" tabindex="-1" id="申请-PM-内存">申请 PM 内存</h4><p>比较自然的想法是参考 malloc 设计一个对应的持久内存版本：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptr = pm_malloc(len); <span class="comment">/* the naïve solution */</span></span><br></pre></td></tr></table></figure><p>看起来很合理，但很快我们就能发现其中的问题：应用之所以申请一段持久内存是为了持久的储存一些数据，因此应用需要一种方式来在重启后重新找到那片内存，因此应用需要给这片内存一个名字用于在下次重新找到它。有很多现成的命名方式供我们使用，例如对象 ID 或者类似 URL 的字符串。在命名后的下一个问题是如何确定应用有这片内存的访问权限，随着对 PM 管理方式的探究，还能发现更多问题，例如系统管理员如何修改 PM 权限、如何删除或重命名 PM、如何备份等等。对于传统储存，这些问题的答案是文件系统，所以尽管持久储存更像系统内存，以文件系统的形式暴露出来会是一个更方便的解决方案。文件 API 为 PM 区域提供了自然的命名空间，提供了创建、删除、重命名和调整大小的方法。当应用需要持久内存时，直接在感知 PM 的文件系统上打开或创建一个文件，并使用 mmap 将它映射到自己的地址空间即可。</p><h4 id="%E6%8C%81%E4%B9%85%E5%8C%96%E6%95%B0%E6%8D%AE" tabindex="-1" id="持久化数据">持久化数据</h4><p>需要储存的数据通常都会被缓存，并且需要通过某种同步 api 来将更改提交到储存介质。对于被映射到内存中的文件来说，msync 实现了该功能。传统 msync 将 page cache 中的数据刷新到储存中，而由于持久内存不需要 page cache，对应的 msync 调用的功能就变成了刷新 CPU cache 或其他保证数据被提交至电源故障安全的状态所需的中间步骤。</p><h4 id="%E5%9C%B0%E5%9D%80%E6%97%A0%E5%85%B3%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84" tabindex="-1" id="地址无关的数据结构">地址无关的数据结构</h4><p>持久内存对于那些需要储存数组、树、堆等数据结构的应用来说很方便，应用可以利用文件 api 映射持久内存来直接访问这些结构。这带来了有关地址无关的数据结构的问题。</p><p><img src="https://s2.loli.net/2024/04/03/hIgy6vjoPTDMq2R.png" alt="典型进程地址空间"></p><p>如上图，进程通过内存映射的方式访问持久内存，持久内存和其他映射到内存的文件（如共享库）一起被映射到内存空间中。各个区域之间有一些带状的空间（阴影部分区域），这片空间的具体大小通常是随机的，这是一种缓解某些类攻击的安全机制。这使得储存在持久内存上的数据结构中的指针会在第二次运行时变得无效，如上图的右侧部分所示。尽管这个问题在映射到内存的文件中就存在了，持久内存的出现使其变得更加普遍。</p><p>显而易见的解决方法是只储存相对 PM 的指针，这种方式需要每个指针解引用都清楚它是一个相对的指针并在其基础上加上一些偏移，因此比较容易出错。有运行时虚拟机或没有显式指针的语言可能可以透明的处理这种情形。一些编译器有 based pointer 这种特性，如微软的 C++ 编译器，使用特殊关键字声明的指针能够在解引用时根据基地址自动计算正确的值，使用起来更加方便。</p><h4 id="%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86" tabindex="-1" id="错误处理">错误处理</h4><p>计算机系统的主存储器通常通过纠错码（ECC）等机制来防止错误。当该内存被应用程序使用时，应用程序通常不处理错误，可纠正的错误被纠正的过程对应用程序而言是透明的（这些错误通常被记录下来供管理员使用）。对于不可纠正的错误，操作系统在可能的情况下可以修复被破坏的应用程序内存（例如，如果内存内容没有被修改，可以重新从磁盘读取数据）。但总会有程序状态被破坏，无法安全的继续运行程序的情况。在大多数 UNIX 系统中，受影响的程序在这种情况下被杀死，UNIX 信号 SIGBUS 最常在此时被使用。</p><p><img src="https://s2.loli.net/2024/04/03/jiaAwCQkyDsHYWI.png" alt="MCA 处理流程"></p><p>PM 的错误处理初看起来和内存相似，以在 Intel 架构上运行的 Linux 为例，内存错误是通过英特尔的 Machine Check Architecture（MCA）来报告的。当操作系统启用这一功能时，上图中的红色实心箭头显示了不可纠正错误的处理流程，当发生错误的位置被访问时，mcheck 模块会收到通知。</p><p>如之前所述，这时向应用程序发送 SIGBUS 信号可以让应用程序决定该做什么，然而由于这片区域是持久内存文件系统某个文件的一部分，即便应用程序会收到信号阻止它使用损坏的数据，也必须提供一个从这种情况中恢复的方法。系统管理员可能会尝试在更换有问题的 PM 之前备份文件系统中的其他数据，但是在我们目前所述的错误机制下，备份程序每次接触到损坏的位置都会收到一个 SIGBUS。在这种情况下，PM 感知的文件系统需要一种机制来接收错误通知，以便它能够隔离受影响的区域，继续提供对 PM 文件系统其余部分的访问。上图中的虚线箭头表示了这种机制，在启动时，文件系统告诉 mcheck 模块哪些 PM 地址范围是自己负责的，之后当错误发生时，文件系统会被 mcheck 模块调用来获得处理这个错误的机会。<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p><p>持久内存层的引入为应用程序开发人员提供了放置数据和数据结构的位置的新选择。传统上，数据被读取和写入易失性内存，然后刷新到非易失性持久存储。当应用程序启动时，必须先将数据从存储器中读取到易失性存储器中，然后才能对其进行访问。根据工作数据集的大小，这可能需要几秒钟、几分钟或几小时。通过巧妙的应用程序设计，开发人员和应用程序架构师现在可以利用这项新技术来提高性能并减少应用程序启动时间。持久内存引入了一些新的编程问题，这些问题不适用于传统的易失性内存。包括：数据持久性：在刷新之前，不能保证存储是持久的。尽管这对于已有数十年历史的内存映射文件 API（如 Linux 上的 mmap() 和 msync()）也是如此，但许多程序员还没有处理需要刷新到内存持久性的问题。遵循标准 API（如 msync() 刷新对持久性的更改）能够按预期工作。但是更优化的刷新使得应用程序直接从 CPU 缓存中刷新存储，而不是调用内核，也是可能的。<br>CPU 具有无序的 CPU 执行和缓存访问/刷新。这意味着如果应用程序存储了两个值，它们持久化的顺序可能不是应用程序写入它们的顺序。数据一致性：<br>8 字节存储在 x86 架构上是电源故障原子性的——如果在向对齐的 8 字节存储到 PMEM 期间发生电源故障，则在重新启动后该位置或者上旧的 8 字节或者是新的 8 字节（而不是两者的结合）。<br>x86 上大于 8 字节的任何内容都不是 powerfail atomic 的，因此需要由软件来实现一致性所需的任何事务/日志记录/恢复。请注意，这是特定于 x86 的——其他硬件平台可能具有不同的原子性大小（PMDK 的设计目的是让使用它的应用程序不必担心这些细节）。内存泄漏：持久存储的内存泄漏是持久的。重新启动服务器不会更改设备上的内容。在当前的 volatile 模型中，如果应用程序泄漏内存，重新启动应用程序或系统会释放该内存。字节级访问：应用开发者可以根据应用需求进行字节级别的读写。读/写不再需要对齐或等于存储块边界，例如：512byte、4KiB 或 8KiB。存储不需要读取整个块来修改几个字节，然后将整个块写回持久存储。应用程序可以根据需要随意读/写。这提高了性能并减少了内存占用开销。错误处理：应用程序可能需要直接检测和处理硬件错误。由于应用程序可以直接访问持久内存介质，因此任何错误都将作为内存错误返回给应用程序。</p><h3 id="pmem" tabindex="-1" id="PMEM">PMEM</h3><h4 id="dax" tabindex="-1" id="DAX">DAX</h4><h4 id="btt" tabindex="-1" id="BTT">BTT</h4><h3 id="%E5%AE%9E%E7%8E%B0" tabindex="-1" id="实现">实现</h3><p>Linux 上关于持久内存的配置概念方面曾经有过一些变动，本章节将以本文撰写时最新内核和工具的支持情况为基础。</p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://www.usenix.org/system/files/login/articles/08_rudoff_040-045_final.pdf">Programming Models for Emerging Non-Volatile Memory Technologies</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    
    <summary type="html">&lt;p&gt;nvdimm，即非易失性双列直插式内存模块（non-volatile DIMM），相对于传统的易失性内存，nvdimm 在断电后其中的内容也不会消失。&lt;/p&gt;
&lt;article class=&quot;message message-immersive is-primary&quot;&gt;
&lt;div class=&quot;message-body&quot;&gt;
&lt;i class=&quot;fas fa-drafting-compass mr-2&quot;&gt;&lt;/i&gt;
施工中！！！
&lt;p&gt;咕咕咕！&lt;/p&gt;
&lt;/div&gt;
&lt;/article&gt;</summary>
    
    
    
    <category term="硬件" scheme="https://universesaurora.top/categories/%E7%A1%AC%E4%BB%B6/"/>
    
    
    <category term="硬件" scheme="https://universesaurora.top/tags/%E7%A1%AC%E4%BB%B6/"/>
    
    <category term="nvdimm" scheme="https://universesaurora.top/tags/nvdimm/"/>
    
  </entry>
  
  <entry>
    <title>小探 GI global-metadata</title>
    <link href="https://universesaurora.top/2022/06/10/gi_research_metadata/"/>
    <id>https://universesaurora.top/2022/06/10/gi_research_metadata/</id>
    <published>2022-06-10T12:07:34.000Z</published>
    <updated>2022-07-18T08:42:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>算是博客的第一篇正式文章。</p><p>最近尝试了一下原神私服，在弄模型替换的时候出了点问题，正好借此机会对游戏做一点探索。</p><article class="message message-immersive is-warning"><div class="message-body"><i class="fas fa-exclamation-triangle mr-2"></i>内容已过时！<p>距本文撰写时已过去较长时间，最新版本的游戏保护方式已经升级，且这篇文章主要是我自己鼓捣的记录，目前已经没有什么价值了。</p></div></article><span id="more"></span><h2 id="%E8%B5%B7%E5%9B%A0" tabindex="-1" id="起因">起因</h2><p>想要在游戏中进行模型替换需要一个叫做 Melonloader 的框架，但这个框架在 2.7 版本中无法使用了<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>。查看产生的 log 可以发现该问题出在 Il2CppDumper 上：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">[20:57:40.389] Executing Il2CppDumper...</span><br><span class="line">[20:57:40.392] &quot;C:\Users\Miguel\Downloads\GrassCutPer\Genshin Impact\Genshin Impact Game\MelonLoader\Dependencies\Il2CppAssemblyGenerator\Il2CppDumper\Il2CppDumper.exe&quot; &quot;C:\Users\Miguel\Downloads\GrassCutPer\Genshin Impact\Genshin Impact Game\YuanShen_Data\Native\UserAssembly.dll&quot; &quot;C:\Users\Miguel\Downloads\GrassCutPer\Genshin Impact\Genshin Impact Game\YuanShen_Data\Native\Data\Metadata\global-metadata.dat&quot;</span><br><span class="line">[20:57:40.766] Initializing metadata...</span><br><span class="line">[20:57:46.401] System.InvalidOperationException: 序列不包含任何元素</span><br><span class="line">[20:57:46.401]    在 System.Linq.Enumerable.Max[TSource](IEnumerable`1 source)</span><br><span class="line">[20:57:46.402]    在 Il2CppDumper.Metadata.&lt;&gt;c.&lt;ProcessingMetadataUsage&gt;b__38_0(KeyValuePair`2 x)</span><br><span class="line">[20:57:46.403]    在 System.Linq.Enumerable.WhereSelectEnumerableIterator`2.MoveNext()</span><br><span class="line">[20:57:46.404]    在 System.Linq.Enumerable.Max[TSource](IEnumerable`1 source)</span><br><span class="line">[20:57:46.405]    在 Il2CppDumper.Metadata.ProcessingMetadataUsage()</span><br><span class="line">[20:57:46.406]    在 Il2CppDumper.Metadata..ctor(Stream stream, StringDecryptionData decData, String nameTranslationPath)</span><br><span class="line">[20:57:46.407]    在 Il2CppDumper.Program.Init(String il2cppPath, String metadataPath, String nameTranslationPath, Metadata&amp; metadata, Il2Cpp&amp; il2Cpp)</span><br><span class="line">[20:57:46.408]    在 Il2CppDumper.Program.Main(String[] args)</span><br><span class="line">[20:57:46.419] Executing Il2CppAssemblyUnhollower...</span><br><span class="line">...</span><br><span class="line">[20:57:46.516] [ERROR] 未经处理的异常:  System.IO.DirectoryNotFoundException: 未能找到路径“C:\Users\Miguel\Downloads\GrassCutPer\Genshin Impact\Genshin Impact Game\MelonLoader\Dependencies\Il2CppAssemblyGenerator\Il2CppDumper\DummyDll”的一部分。</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>经过一番搜索后，我发现这个 Il2CppDumper 实际上是被修改过的，原本的 Il2CppDumper 只能解析出 unity 正常生成的 global-metadata.dat，但游戏将 global-metadata.dat 文件进行了一些混淆，所以不将其解密是无法成功将元数据导出来的。Il2CppDumper 大概的作用就是把经过 Il2Cpp 转换后需要用到的符号还原出来并生成一系列 dll 文件，而 Melonloader 的运行应该需要用到这些 dll 文件。</p><p>这样看来应该是 2.7 版本的混淆方法有了变化，导致这个针对之前设计的 Il2CppDumper 没法正确解密了。虽然静等作者更新这个程序也不是不行，但刚好我之前有过探索下这个游戏背后的程序结构之类的想法，于是就打算自己分析分析看看能不能把这个解密方法修复下。</p><h2 id="%E8%A1%8C%E4%B8%BA" tabindex="-1" id="行为">行为</h2><p>用二进制编辑器看了下 metadata 文件，头部的标志已经没有了，和之前版本的对比了下也没看出来什么门道。我首先想到的是抓抓系统调用看看打开 metadata 文件的前后发生了些啥，然而抓了后又把 map/read 之类操作和 metadata 文件对了下，依然看不出什么东西，显然这种简单的分析是完全没用的。更诡异的是运行几次后连 read 都抓不到了，难不成这东西还有缓存的？</p><p><img src="https://s2.loli.net/2024/04/03/hfstbQ7xYXHlL6A.png" alt="Process Monitor 记录"></p><h2 id="%E5%88%86%E6%9E%90-userassembly.dll" tabindex="-1" id="分析-UserAssembly-dll">分析 UserAssembly.dll</h2><p>于是把 UserAssembly.dll 丢进 ida 分析了下。直接搜索字符串 global-metadata，找到了看起来可能是打开文件的地方：</p><p><img src="https://s2.loli.net/2024/04/03/l8Sg1sK3fNZ579v.png" alt="疑似打开文件"></p><p>于是我参考了网上相关文章研究了下，怀疑到下面有一处调用的解密函数，这个函数初始化在一个导出函数中，其中还初始化了另一个函数。</p><p><img src="https://s2.loli.net/2024/04/03/PnVLSlZ4Br1cY9t.png" alt="初始化解密函数"></p><p>不过解密函数目前来看都不在这个 dll 中，四处翻了翻后我就暂时结束了对 UserAssembly.dll 的探索。</p><h2 id="%E5%88%86%E6%9E%90-il2cppdumper" tabindex="-1" id="分析-Il2CppDumper">分析 Il2CppDumper</h2><p>接下来我把目光转向了 Il2CppDumper，想通过它分析下之前版本的 metadata 是怎么解密出来的（没找到这个被修改过的 Il2CppDumper 源码）（更新：其实是有源码的，在另一个<a href="https://github.com/Three-taile-dragon/MelonLoader-GenshinImpact">仓库</a>）。于是把他丢进 ida，搜索打印的 log 字符串 “Initializing metadata…”，很快我就发现了一个叫做 DecryptMetadata 的函数，显然是解密函数：</p><p><img src="https://s2.loli.net/2024/04/03/GWz6xik3fAShbCy.png" alt="DecryptMetadata"></p><p>ida 好像反汇编不了 .net 的程序，换个反编译工具 dnSpy，这下源码基本完全解析出来了。首先动态调试了下，找到异常抛出的位置向前回溯，发现问题出自 header.metadataUsageListsCount 为 0，这个 header 又是通过之前解密的 metadata 数据初始化出来的，这样看 metadata 果然还是没有被正确解密。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> MetadataDecryption.<span class="function">StringDecryptionData <span class="title">DecryptMetadata</span>(<span class="params"><span class="built_in">byte</span>[] metadata</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">MetadataDecryption.DecryptMetadataBlocks(metadata);</span><br><span class="line"><span class="keyword">return</span> MetadataDecryption.DecryptMetadataStringInfo(metadata);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>细看第一个解密函数 DecryptMetadataBlocks，先是从文件后部复制了点数据，之后做了个比较。奇怪的是这个比较通过了，我又在二进制编辑器里对了下这个值，确实是对的，看来加密逻辑没有变动太多？</p><figure class="highlight csharp"><figcaption><span>第一个解密函数</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DecryptMetadataBlocks</span>(<span class="params"><span class="built_in">byte</span>[] metadata</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">byte</span>[] array = <span class="keyword">new</span> <span class="built_in">byte</span>[<span class="number">16384</span>];</span><br><span class="line">Buffer.BlockCopy(metadata, metadata.Length - array.Length, array, <span class="number">0</span>, array.Length);</span><br><span class="line"><span class="keyword">if</span> (array[<span class="number">200</span>] != <span class="number">46</span> || array[<span class="number">201</span>] != <span class="number">252</span> || array[<span class="number">202</span>] != <span class="number">254</span> || array[<span class="number">203</span>] != <span class="number">44</span>)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException(<span class="string">&quot;*((uint32_t*)&amp;footer[0xC8]) != 0x2CFEFC2E&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后面主要就是数据复制，用异或方法压缩出了一个 key，之后又异或了一堆奇怪的预定义的值。看来之前加密的逻辑主要还是异或，还用到了一些预先定义好的数据。到这里感觉从 Il2CppDumper 也不再能看出太多了。</p><h2 id="%E6%90%AD%E5%BB%BA%E4%B8%BB%E7%A8%8B%E5%BA%8F%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83" tabindex="-1" id="搭建主程序调试环境">搭建主程序调试环境</h2><p>推测下解密函数很有可能应该在主程序 YuanShen.exe 里面了，研究了下找到个方法能通过调试器直接启动游戏本体进私服，方便之后调试。（更新：其实只要用的是 Fiddler 这种抓包软件就行了，效果一样且更方便）</p><p>修改 GrassClipper 的 scripts/private_server_launch.cmd，找到这里：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:: Launch game</span><br><span class="line">&quot;<span class="variable">%GAME_PATH%</span>&quot;</span><br></pre></td></tr></table></figure><p>把 <code>&quot;%GAME_PATH%&quot;</code> 这部分注释掉，加个 pause。之后启动先把 grasscutter 服务端跑起来，然后在命令行运行这个脚本，带上下面这些参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private_server_launch.cmd 127.0.0.1 443 <span class="literal">true</span> <span class="string">&quot;&lt;YuanShen.exe 路径&gt;&quot;</span> <span class="string">&quot;&lt;GrassClipper 路径&gt;&quot;</span> <span class="literal">false</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>这里服务地址端口都是默认的配置，之后这个脚本会把代理开起来，接下来直接运行游戏本体就能进私服了，关闭记得在终端输入字符把剩下的关闭流程跑完，否则代理设置不会被清除掉没法正常联网。</p><p>搭好调试环境后，我发现这游戏主程序加了壳的没法直接调试（废话），想在游戏过程中挂 x64dbg 也挂不上，不知道用了什么魔法。另外游戏会不断检查并尝试杀掉 x64dbg 等调试器，启动时也会检查，以及如果杀不掉甚至游戏直接退出。所以这个部分遇到了点困难。</p><p><img src="https://s2.loli.net/2024/04/03/9UpEjDZofeK2kwd.png" alt="本体有 vmp 壳"></p><h2 id="%E5%B0%9D%E8%AF%95%E6%96%B0%E7%9A%84-il2cppdumper" tabindex="-1" id="尝试新的-Il2CppDumper">尝试新的 Il2CppDumper</h2><p>回来更新文章了，发现已经有人更新了针对 2.7+ 版本的 Il2CppDumper<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>，所以尝试直接用它替换掉原本的 Il2CppDumper。</p><p>运行后 Il2CppDumper 成功生成了 DummyDll，但是还是有其他错误，下面是比较关键的部分：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">[01:25:26.036] ------------------------------</span><br><span class="line">[01:25:26.037] Game Name: 原神</span><br><span class="line">[01:25:26.037] Game Developer: miHoYo</span><br><span class="line">[01:25:26.038] Unity Version: 2017.4.30f1</span><br><span class="line">[01:25:26.038] Game Version:</span><br><span class="line">[01:25:26.039] ------------------------------</span><br><span class="line">[01:25:26.379] Preferences Loaded!</span><br><span class="line">[01:25:26.398] [Il2CppUnityTls] Patching mono_unity_get_unitytls_interface...</span><br><span class="line">[01:25:26.401] Loading Plugins...</span><br><span class="line"></span><br><span class="line">[01:25:26.409] ------------------------------</span><br><span class="line">[01:25:26.409] No Plugins Loaded!</span><br><span class="line">[01:25:26.410] ------------------------------</span><br><span class="line">[libil2cpp] Failed to resolve 3441514353 at startup</span><br><span class="line">[libil2cpp] Failed to resolve 2641773275 at startup</span><br><span class="line">[libil2cpp] Failed to resolve 3753878500 at startup</span><br><span class="line">[libil2cpp] Failed to resolve 1688788800 at startup</span><br><span class="line">[libil2cpp] Failed to resolve 226400704 at startup</span><br><span class="line">[libil2cpp] Failed to resolve 58785463 at startup</span><br><span class="line">[libil2cpp] Failed to resolve 1939797683 at startup</span><br><span class="line">[libil2cpp] Failed to resolve 2903149294 at startup</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">[00:50:23.258] &quot;C:\Users\Miguel\Downloads\gi-priv\games\gi_2.7.0_self\Genshin Impact Game\MelonLoader\Dependencies\Il2CppAssemblyGenerator\Il2CppAssemblyUnhollower\AssemblyUnhollower.exe&quot; &quot;--input=C:\Users\Miguel\Downloads\gi-priv\games\gi_2.7.0_self\Genshin Impact Game\MelonLoader\Dependencies\Il2CppAssemblyGenerator\Il2CppDumper\DummyDll&quot; &quot;--output=C:\Users\Miguel\Downloads\gi-priv\games\gi_2.7.0_self\Genshin Impact Game\MelonLoader\Dependencies\Il2CppAssemblyGenerator\Il2CppAssemblyUnhollower\Managed&quot; &quot;--mscorlib=C:\Users\Miguel\Downloads\gi-priv\games\gi_2.7.0_self\Genshin Impact Game\MelonLoader\Managed\mscorlib.dll&quot; &quot;--unity=C:\Users\Miguel\Downloads\gi-priv\games\gi_2.7.0_self\Genshin Impact Game\MelonLoader\Dependencies\Il2CppAssemblyGenerator\UnityDependencies&quot; &quot;--gameassembly=C:\Users\Miguel\Downloads\gi-priv\games\gi_2.7.0_self\Genshin Impact Game\YuanShen_Data\Native\UserAssembly.dll&quot; &quot;--add-prefix-to=ICSharpCode&quot; &quot;--add-prefix-to=Newtonsoft&quot; &quot;--add-prefix-to=TinyJson&quot; &quot;--add-prefix-to=Valve.Newtonsoft&quot; &quot;--no-xref-cache&quot;</span><br><span class="line">[00:50:23.348] Reading assemblies... </span><br><span class="line">[00:50:23.538] Done in 00:00:00.1889345</span><br><span class="line">[00:50:23.539] Reading system assemblies... </span><br><span class="line">[00:50:23.552] Done in 00:00:00.0138266</span><br><span class="line">[00:50:23.553] Reading unity assemblies... </span><br><span class="line">[00:50:23.563] Done in 00:00:00.0100095</span><br><span class="line">[00:50:23.564] Creating rewrite assemblies... </span><br><span class="line">[00:50:23.584] Done in 00:00:00.0218627</span><br><span class="line">[00:50:23.585] Computing renames... </span><br><span class="line">[00:50:23.616] [ERROR] </span><br><span class="line">[00:50:23.657] [ERROR] 未经处理的异常:  Mono.Cecil.AssemblyResolutionException: Failed to resolve assembly: &#x27;System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e&#x27;</span><br><span class="line">[00:50:23.658] [ERROR]    在 Mono.Cecil.BaseAssemblyResolver.Resolve(AssemblyNameReference name, ReaderParameters parameters)</span><br><span class="line">[00:50:23.659] [ERROR]    在 Mono.Cecil.DefaultAssemblyResolver.Resolve(AssemblyNameReference name)</span><br><span class="line">[00:50:23.659] [ERROR]    在 Mono.Cecil.MetadataResolver.Resolve(TypeReference type)</span><br><span class="line">[00:50:23.660] [ERROR]    在 Mono.Cecil.TypeReference.Resolve()</span><br><span class="line">[00:50:23.661] [ERROR]    在 AssemblyUnhollower.Passes.Pass05CreateRenameGroups.NameOrRename(TypeReference typeRef, RewriteGlobalContext context)</span><br><span class="line">[00:50:23.662] [ERROR]    在 AssemblyUnhollower.Passes.Pass05CreateRenameGroups.GenericNameToStrings(TypeReference typeRef, RewriteGlobalContext context)</span><br><span class="line">[00:50:23.663] [ERROR]    在 AssemblyUnhollower.Passes.Pass05CreateRenameGroups.GetUnobfuscatedNameBase(RewriteGlobalContext context, TypeDefinition typeDefinition, Boolean allowExtraHeuristics)</span><br><span class="line">[00:50:23.664] [ERROR]    在 AssemblyUnhollower.Passes.Pass05CreateRenameGroups.ProcessType(RewriteGlobalContext context, TypeDefinition originalType, Boolean allowExtraHeuristics)</span><br><span class="line">[00:50:23.665] [ERROR]    在 AssemblyUnhollower.Passes.Pass05CreateRenameGroups.ProcessType(RewriteGlobalContext context, TypeDefinition originalType, Boolean allowExtraHeuristics)</span><br><span class="line">[00:50:23.665] [ERROR]    在 AssemblyUnhollower.Passes.Pass05CreateRenameGroups.DoPass(RewriteGlobalContext context)</span><br><span class="line">[00:50:23.666] [ERROR]    在 AssemblyUnhollower.Program.Main(UnhollowerOptions options)</span><br><span class="line">[00:50:23.667] [ERROR]    在 AssemblyUnhollower.Program.Main(String[] args)</span><br><span class="line">[00:50:25.289] Done in 00:00:01.7042110</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[00:50:25.370] Loading Mods...</span><br><span class="line">[00:50:25.389] [ERROR] No MelonInfoAttribute Found in C:\Users\Miguel\Downloads\gi-priv\games\gi_2.7.0_self\Genshin Impact Game\Mods\ClassLibrary3.dll</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">[00:50:25.499] [ERROR] Field internalEncoding was not found on class StreamWriter</span><br><span class="line">[00:50:25.500] [ERROR] Field internalStream was not found on class StreamWriter</span><br><span class="line">[00:50:25.502] [ERROR] Field iflush was not found on class StreamWriter</span><br><span class="line">[00:50:25.503] [ERROR] Field byte_buf was not found on class StreamWriter</span><br><span class="line">[00:50:25.504] [ERROR] Field byte_pos was not found on class StreamWriter</span><br><span class="line">[00:50:25.504] [ERROR] Field decode_buf was not found on class StreamWriter</span><br><span class="line">[00:50:25.505] [ERROR] Field decode_pos was not found on class StreamWriter</span><br><span class="line">[00:50:25.506] [ERROR] Field DisposedAlready was not found on class StreamWriter</span><br><span class="line">[00:50:25.506] [ERROR] Field preamble_done was not found on class StreamWriter</span><br><span class="line">[00:50:25.507] [ERROR] Field internalFormatProvider was not found on class TextWriter</span><br></pre></td></tr></table></figure><p>这里放的 log 比较多，大部分内容在之前的 log 中也是有的，不同的部分在于 Il2CppDumper 生成 DummyDll 后接着又运行的 Il2CppAssemblyUnhollower 给出的错误。</p><p>从 trace 来看 AssemblyUnhollower 又用到了 Mono.Cecil 这个库，在该库中抛出了一个异常。除此之外开头部分的 libil2cpp 也还不清楚是谁打印的，这部分错误从一开始就存在，且没有被写入 log 文件中，可能比较特殊。</p><p>于是我又从网上找了一个 <a href="https://gh.fakev.cn/RoflanProgers/Il2CppAssemblyUnhollower-GenshinImpact">Il2CppAssemblyUnhollower 源码</a>，这个原仓库应该是没了，链接的是镜像站。抱着试一试的心态编译了一下，发现并没有出现类似报错，不过出现了 methods failed to restore 的情况，不知道是否正常。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">Reading assemblies...</span><br><span class="line">Done in 00:00:00.2249948</span><br><span class="line">Reading system assemblies...</span><br><span class="line">Done in 00:00:00.0138076</span><br><span class="line">Reading unity assemblies...</span><br><span class="line">Done in 00:00:00.0249082</span><br><span class="line">Creating rewrite assemblies...</span><br><span class="line">Done in 00:00:00.0095615</span><br><span class="line">Computing renames...</span><br><span class="line">Done in 00:00:00.0759375</span><br><span class="line">Creating typedefs...</span><br><span class="line">Done in 00:00:00.3707064</span><br><span class="line">Computing struct blittability...</span><br><span class="line">Done in 00:00:00.0270083</span><br><span class="line">Filling typedefs...</span><br><span class="line">Done in 00:00:00.0354803</span><br><span class="line">Filling generic constraints...</span><br><span class="line">Done in 00:00:00.0068350</span><br><span class="line">Creating members...</span><br><span class="line">Done in 00:00:04.5136379</span><br><span class="line">Scanning method cross-references...</span><br><span class="line">Done in 00:00:01.7303552</span><br><span class="line">Finalizing method declarations...</span><br><span class="line">Done in 00:00:10.2081680</span><br><span class="line">0 total potentially dead methods</span><br><span class="line">Filling method parameters...</span><br><span class="line">Done in 00:00:00.7021279</span><br><span class="line">Creating static constructors...</span><br><span class="line">Done in 00:00:02.1416967</span><br><span class="line">Creating value type fields...</span><br><span class="line">Done in 00:00:00.1698024</span><br><span class="line">Creating enums...</span><br><span class="line">Done in 00:00:00.0984626</span><br><span class="line">Creating IntPtr constructors...</span><br><span class="line">Done in 00:00:00.1559927</span><br><span class="line">Creating type getters...</span><br><span class="line">Done in 00:00:00.2090254</span><br><span class="line">Creating non-blittable struct constructors...</span><br><span class="line">Done in 00:00:00.0172973</span><br><span class="line">Creating generic method static constructors...</span><br><span class="line">Done in 00:00:00.0622003</span><br><span class="line">Creating field accessors...</span><br><span class="line">Done in 00:00:03.4009610</span><br><span class="line">Filling methods...</span><br><span class="line">Done in 00:00:03.5433611</span><br><span class="line">Generating implicit conversions...</span><br><span class="line">Done in 00:00:00.0293020</span><br><span class="line">Creating properties...</span><br><span class="line">Done in 00:00:00.2467474</span><br><span class="line">Unstripping types...</span><br><span class="line">Done in 00:00:00.0325269</span><br><span class="line">Unstripping fields...</span><br><span class="line"></span><br><span class="line">286 fields restored</span><br><span class="line">7 fields failed to restore</span><br><span class="line">Done in 00:00:00.0090604</span><br><span class="line">Unstripping methods...</span><br><span class="line"></span><br><span class="line">7760 methods restored</span><br><span class="line">213 methods failed to restore</span><br><span class="line">Done in 00:00:00.3213333</span><br><span class="line">Unstripping method bodies...</span><br><span class="line"></span><br><span class="line">IL unstrip statistics: 3567 successful, 594 failed</span><br><span class="line">Done in 00:00:00.1510770</span><br><span class="line">Generating forwarded types...</span><br><span class="line">Done in 00:00:00.0416483</span><br><span class="line">Writing xref cache...</span><br><span class="line">Done in 00:00:00.0073933</span><br><span class="line">Writing assemblies...</span><br><span class="line">Done in 00:00:10.7976969</span><br><span class="line">Writing method pointer map...</span><br><span class="line">Done in 00:00:00.1345476</span><br><span class="line">Done!</span><br></pre></td></tr></table></figure><p>赶紧放到 MelonLoader 里试一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[14:07:32.626] ------------------------------</span><br><span class="line">[14:07:32.627] 4 Mods Loaded</span><br><span class="line">[14:07:32.627] ------------------------------</span><br><span class="line">[14:07:32.628] Camera Tools v1.0.6</span><br><span class="line">[14:07:32.628] by portra</span><br><span class="line">[14:07:32.631] SHA256 Hash: 12464c1f24f4267a3f75afc6a26f2148b7b0fd6a7d2c9607f8dac0c91d20ac50</span><br><span class="line">[14:07:32.631] ------------------------------</span><br><span class="line">[14:07:32.632] HideUIScript v1.0.0</span><br><span class="line">[14:07:32.632] by Taiga74164</span><br><span class="line">[14:07:32.633] SHA256 Hash: 2b272e95f1062d01800c4da58f7dee800aeb8726a47ec2da02507bfa82c31640</span><br><span class="line">[14:07:32.634] ------------------------------</span><br><span class="line">[14:07:32.634] Model Changer v0.0.8</span><br><span class="line">[14:07:32.635] by portra</span><br><span class="line">[14:07:32.638] SHA256 Hash: dd7c505195b0ea8151945b7e1dc66a1583fa9488c6175808da6957fbe20ecde1</span><br><span class="line">[14:07:32.638] ------------------------------</span><br><span class="line">[14:07:32.638] UnityExplorer v4.9.0</span><br><span class="line">[14:07:32.639] by Sinai</span><br><span class="line">[14:07:32.663] SHA256 Hash: 09f49edd0be7c2c1aecbb892e360230094fd172acac51dce8f75557f3873946a</span><br><span class="line">[14:07:32.664] ------------------------------</span><br><span class="line">[14:07:32.668] [ERROR] No Support Module Loaded!</span><br></pre></td></tr></table></figure><p>游戏成功启动，但是 UnityExplorer 并没有加载，log 如上，之前的错误中除了 libil2cpp 的报错都已经消失了。</p><p>看这个错误是 mod 不受支持，在 MelonLoader 源码中找到了该打印的来源：</p><figure class="highlight csharp"><figcaption><span>MelonLoader\SupportModule\SupportModule.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Interface == <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">MelonLogger.Error(<span class="string">&quot;No Support Module Loaded!&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在里面加了一些打印：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[15:12:28.210] [ERROR] Found: System.Collections.Generic.List`1[MelonLoader.SupportModule+ModuleListing]</span><br><span class="line">[15:12:28.210] [ERROR] Found: C:\Users\Miguel\Downloads\gi-priv\games\gi_2.7.0_self\Genshin Impact Game\MelonLoader\Dependencies\SupportModules\Il2Cpp.dll</span><br><span class="line">[15:12:28.211] [ERROR] Loading: C:\Users\Miguel\Downloads\gi-priv\games\gi_2.7.0_self\Genshin Impact Game\MelonLoader\Dependencies\SupportModules\Il2Cpp.dll</span><br><span class="line">[15:12:28.213] [ERROR] Support Module [Il2Cpp.dll] threw an Exception: System.Reflection.TargetInvocationException: Exception has been thrown by the target of an invocation. ---&gt; System.IO.FileNotFoundException: Could not load file or assembly &#x27;netstandard, Version=2.1.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51&#x27; or one of its dependencies.</span><br><span class="line">  at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&amp;)</span><br><span class="line">  at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x00032] in &lt;e1319b7195c343e79b385cd3aa43f5dc&gt;:0</span><br><span class="line">   --- End of inner exception stack trace ---</span><br><span class="line">  at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x00048] in &lt;e1319b7195c343e79b385cd3aa43f5dc&gt;:0</span><br><span class="line">  at System.Reflection.MethodBase.Invoke (System.Object obj, System.Object[] parameters) [0x00000] in &lt;e1319b7195c343e79b385cd3aa43f5dc&gt;:0</span><br><span class="line">  at MelonLoader.SupportModule.LoadInterface (System.String ModulePath) [0x00063] in &lt;20bb3b548fca4badbe0683004df1b626&gt;:0</span><br><span class="line">  at MelonLoader.SupportModule.Setup () [0x000c3] in &lt;20bb3b548fca4badbe0683004df1b626&gt;:0</span><br><span class="line">[15:12:28.214] [ERROR] Found: C:\Users\Miguel\Downloads\gi-priv\games\gi_2.7.0_self\Genshin Impact Game\MelonLoader\Dependencies\SupportModules\Mono.dll</span><br><span class="line">[15:12:28.217] [ERROR] No Support Module Loaded!</span><br></pre></td></tr></table></figure><p>看起来是和 Il2Cpp.dll 有关。</p><h2 id="%E5%85%B3%E4%BA%8E%E5%8F%8D%E8%B0%83%E8%AF%95" tabindex="-1" id="关于反调试">关于反调试</h2><p>之前稍微试着用 x64dbg 调试了下，感觉它应该是通过 mhypbase.dll 这个东西实现反调试的，由他加载 mhyprot2.Sys 和 mhyprot3.Sys 这两个驱动。用 ScyllaHide 的默认配置似乎会导致程序跳到0地址。这方面经验不多就不写了。</p><p>更新：由于有其他事情很长时间没有再研究这个问题，之后应该不会更新这篇文章了。如果有新进展会另开一篇。</p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://github.com/lassedds/Melonloader-AnimeGaming/issues/3">该问题的 Github Issue</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p><a href="https://github.com/1582421598/Il2CppDumper-Genshin">2.7+ 版本的 Il2CppDumper</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    
    <summary type="html">&lt;p&gt;算是博客的第一篇正式文章。&lt;/p&gt;
&lt;p&gt;最近尝试了一下原神私服，在弄模型替换的时候出了点问题，正好借此机会对游戏做一点探索。&lt;/p&gt;
&lt;article class=&quot;message message-immersive is-warning&quot;&gt;
&lt;div class=&quot;message-body&quot;&gt;
&lt;i class=&quot;fas fa-exclamation-triangle mr-2&quot;&gt;&lt;/i&gt;
内容已过时！
&lt;p&gt;距本文撰写时已过去较长时间，最新版本的游戏保护方式已经升级，且这篇文章主要是我自己鼓捣的记录，目前已经没有什么价值了。&lt;/p&gt;
&lt;/div&gt;
&lt;/article&gt;</summary>
    
    
    
    <category term="逆向" scheme="https://universesaurora.top/categories/%E9%80%86%E5%90%91/"/>
    
    
    <category term="逆向" scheme="https://universesaurora.top/tags/%E9%80%86%E5%90%91/"/>
    
    <category term="游戏" scheme="https://universesaurora.top/tags/%E6%B8%B8%E6%88%8F/"/>
    
  </entry>
  
  <entry>
    <title>序</title>
    <link href="https://universesaurora.top/2022/05/28/preface/"/>
    <id>https://universesaurora.top/2022/05/28/preface/</id>
    <published>2022-05-28T16:05:54.000Z</published>
    <updated>2022-05-29T03:22:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>总之是本博客的第一篇文章。</p><span id="more"></span><p>大概是我建的第三个博客了，之前的几个因为各种原因现在连记录都已经没有了。第一个博客是大概 18 年 5 月，我在自己的主机上用 Wordpress 搭建的。和现在这个不同，当时用的是 .com 域名。但是之前实际上也没写什么东西出来，唯一一个比较可惜的是写过一篇关于 Windows 驱动的文章，现在也没有备份了。</p><p>之所以又建了这个博客是因为最近又觉得自己应该有一个能写些东西的地方，在已有的平台上写总感觉有些拘束，不如自己建一个更自由些。</p><p>这个博客是用 <a href="https://hexo.io/zh-cn/">Hexo</a> 搭建的，托管在 <a href="https://github.com/UniversesAurora/universesaurora-blog">github</a> 上，相对方便一些。</p><p>之后应该不会再把博客删掉了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;总之是本博客的第一篇文章。&lt;/p&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://universesaurora.top/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="随笔" scheme="https://universesaurora.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
