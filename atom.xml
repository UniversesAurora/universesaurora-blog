<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>浮枕星海</title>
  
  <subtitle>浮枕 blog</subtitle>
  <link href="https://universesaurora.top/atom.xml" rel="self"/>
  
  <link href="https://universesaurora.top/"/>
  <updated>2022-08-01T03:12:26.000Z</updated>
  <id>https://universesaurora.top/</id>
  
  <author>
    <name>浮枕</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>nvdimm 技术与编程模型概览</title>
    <link href="https://universesaurora.top/2022/07/18/nvdimm-intro/"/>
    <id>https://universesaurora.top/2022/07/18/nvdimm-intro/</id>
    <published>2022-07-18T08:45:16.000Z</published>
    <updated>2022-08-01T03:12:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>nvdimm，即非易失性双列直插式内存模块（non-volatile DIMM），相对于传统的易失性内存，nvdimm 在断电后其中的内容也不会消失。</p><span id="more"></span><p>定义于 ACPI（NFIT），UEFI（BTT），带外通信使用 DSM。</p><p>交错本来是传统易失性内存中的一个概念。N 代表数字，和 N 通道不是一个概念，只有交错后才能叫做 N 路.</p><h2 id="%E7%90%86%E8%AE%BA" tabindex="-1" id="理论">理论</h2><p>本节参考 <a href="https://www.usenix.org/system/files/login/articles/08_rudoff_040-045_final.pdf">Programming Models for Emerging Non-Volatile Memory Technologies</a> 和 <a href="https://www.usenix.org/system/files/login/articles/login_summer17_07_rudoff.pdf">Persistent Memory Programming</a> 这两篇文章，讲述几种理论上的持久化内存编程模型和有关的问题。文章中的 NVM 泛指各种非易失性内存设备。</p><h3 id="%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B" tabindex="-1" id="编程模型">编程模型</h3><p>理论上有很多种可能的持久化内存编程模型，这里主要聚焦在最相关的的四种。NVM Block Mode 和 NVM File Mode 代表的是过去最常用的储存接口，PM Volume Mode 和 PM File Mode 则主要针对持久内存。</p><h4 id="nvm-block-mode" tabindex="-1" id="NVM-Block-Mode">NVM Block Mode</h4><p><img src="https://s2.loli.net/2022/07/28/XtqEZyMAUaG84pu.png" alt="NVM Block Mode"></p><p>上图表示了常见软件栈的一部分，红线表示了 NVM Block Mode 的接口，这里的接口指的是块读写接口。可以看到，在这个模型中驱动向文件系统等内核模块或直接向应用程序（如直接打开 /dev/sda1 设备）提供了传统块读写接口。为了使这种传统的接口更好的支持非易失性内存设备，可能需要对它进行功能上的扩展，以得到 I/O 性能的优化，例如一些原子操作的支持，向应用程序提供非易失性内存的某些属性等。通过将这种扩展标准化，能够为软件编写者提供一个更有效的生态系统来开发非易失性内存感知的应用程序。</p><h4 id="nvm-file-mode" tabindex="-1" id="NVM-File-Mode">NVM File Mode</h4><p><img src="https://s2.loli.net/2022/07/28/DyOWe15t79fRSLh.png" alt="NVM File Mode"></p><p>NVM File Mode 模式中主要关注的是应用程序和文件系统间的文件接口。和 NVM Block Mode 一样，为了更好的支持非易失性内存设备，文件接口可能需要进行一些扩展。</p><p>例如，MySQL 数据库的双重写入技术防止数据库在遇到电源故障等情况时，储存在文件中的数据表中的页面只被部分写入。如果数据库能够感知到硬件能够保证对于一定大小的页面写入不会因为系统中断导致撕裂，就可以避免双重写入的过程。为应用程序提供一个获取 powerfail write atomicity 的接口可以让程序自己决定合适的行为。</p><h4 id="pm-volume-mode" tabindex="-1" id="PM-Volume-Mode">PM Volume Mode</h4><p><img src="https://s2.loli.net/2022/07/28/9GnibhJySAfvmUt.png" alt="PM Volume Mode"></p><p>如上图，在 PM Volume Mode 中，非易失性内存设备（NVM devices）是支持 PM 的，意味着设备可以通过处理器的 load 和 store 指令直接操作。尽管任何储存元件都可能通过一种处理器可以直接从中加载数据的方式连接到系统，但 NAND Flash 等技术会使处理器在加载时暂停，使得这种连接方式难以实现。更先进的非易失性内存设备和缓存技术使得这种方式成为可能。</p><p>在 PM Volume 模式下，内核组件可以直接访问持久内存区域。上图中红线标出的接口使得能够感知 PM 的内核模块和 NVM 驱动进行通信，这是为了让内核模块获取持久内存的物理地址范围。在这之后他就不再需要调用 NVM 驱动，而是直接通过地址访问持久内存。</p><h4 id="pm-file-mode" tabindex="-1" id="PM-File-Mode">PM File Mode</h4><p><img src="https://s2.loli.net/2022/07/28/vDwTH3WzYe56amu.png" alt="PM File Mode"></p><p>PM File Mode 看起来和 NVM File Mode 有些相似，但不同的是这里的文件系统是感知 PM 的，可以看到这种文件系统就是通过上文的 PM Volume Mode 模型实现的。</p><p>感知 PM 的文件系统提供了所有传统文件系统会提供的文件接口，实际上它通常通过在已有的文件系统的基础上扩展 PM 感知能力来实现的。这种模式最主要的特点是，在使用 mmap 将一个文件 map 到内存空间时，应用程序可以绕过内核直接 load/store 持久内存，而在传统文件系统中文件 mmap 到内存中时需要使用 page cache 机制。</p><h3 id="persistent-memory" tabindex="-1" id="Persistent-Memory">Persistent Memory</h3><p>与 NVM Block Mode 和 NVM File Mode 的增量式改进不同，PM 的改进更具有颠覆性。正如 CPU 从提高频率到提高核心数量的转变时应用需要重新思考他们的算法并转向多线程编程一样，PM 结合了持久性和无需先进行块 I/O 的能力，它使我们重新思考数据结构以什么形式持久的储存。</p><h4 id="%E7%94%B3%E8%AF%B7-pm-%E5%86%85%E5%AD%98" tabindex="-1" id="申请-PM-内存">申请 PM 内存</h4><p>比较自然的想法是参考 malloc 设计一个对应的持久内存版本：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptr = pm_malloc(len); <span class="comment">/* the naïve solution */</span></span><br></pre></td></tr></table></figure><p>看起来很合理，但很快我们就能发现其中的问题：应用之所以申请一段持久内存是为了持久的储存一些数据，因此应用需要一种方式来在重启后重新找到那片内存，因此应用需要给这片内存一个名字用于在下次重新找到它。有很多现成的命名方式供我们使用，例如对象 ID 或者类似 URL 的字符串。在命名后的下一个问题是如何确定应用有这片内存的访问权限，随着对 PM 管理方式的探究，还能发现更多问题，例如系统管理员如何修改 PM 权限、如何删除或重命名 PM、如何备份等等。对于传统储存，这些问题的答案是文件系统，所以尽管持久储存更像系统内存，以文件系统的形式暴露出来会是一个更方便的解决方案。文件 API 为 PM 区域提供了自然的命名空间，提供了创建、删除、重命名和调整大小的方法。当应用需要持久内存时，直接在感知 PM 的文件系统上打开或创建一个文件，并使用 mmap 将它映射到自己的地址空间即可。</p><h4 id="%E6%8C%81%E4%B9%85%E5%8C%96%E6%95%B0%E6%8D%AE" tabindex="-1" id="持久化数据">持久化数据</h4><p>需要储存的数据通常都会被缓存，并且需要通过某种同步 api 来将更改提交到储存介质。对于被映射到内存中的文件来说，msync 实现了该功能。传统 msync 将 page cache 中的数据刷新到储存中，而由于持久内存不需要 page cache，对应的 msync 调用的功能就变成了刷新 CPU cache 或其他保证数据被提交至电源故障安全的状态所需的中间步骤。</p><h4 id="%E5%9C%B0%E5%9D%80%E6%97%A0%E5%85%B3%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84" tabindex="-1" id="地址无关的数据结构">地址无关的数据结构</h4><p>持久内存对于那些需要储存数组、树、堆等数据结构的应用来说很方便，应用可以利用文件 api 映射持久内存来直接访问这些结构。这带来了有关地址无关的数据结构的问题。</p><p><img src="https://s2.loli.net/2022/08/16/5iWeK34PTRsoLzX.png" alt="典型进程地址空间"></p><p>如上图，进程通过内存映射的方式访问持久内存，持久内存和其他映射到内存的文件（如共享库）一起被映射到内存空间中。各个区域之间有一些带状的空间（阴影部分区域），这片空间的具体大小通常是随机的，这是一种缓解某些类攻击的安全机制。这使得储存在持久内存上的数据结构中的指针会在第二次运行时变得无效，如上图的右侧部分所示。尽管这个问题在映射到内存的文件中就存在了，持久内存的出现使其变得更加普遍。</p><p>显而易见的解决方法是只储存相对 PM 的指针，这种方式需要每个指针解引用都清楚它是一个相对的指针并在其基础上加上一些偏移，因此比较容易出错。有运行时虚拟机或没有显式指针的语言可能可以透明的处理这种情形。一些编译器有 based pointer 这种特性，如微软的 C++ 编译器，使用特殊关键字声明的指针能够在解引用时根据基地址自动计算正确的值，使用起来更加方便。</p><h4 id="%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86" tabindex="-1" id="错误处理">错误处理</h4><p>计算机系统的主存储器通常通过纠错码（ECC）等机制来防止错误。当该内存被应用程序使用时，应用程序通常不处理错误，可纠正的错误被纠正的过程对应用程序而言是透明的（这些错误通常被记录下来供管理员使用）。对于不可纠正的错误，操作系统在可能的情况下可以修复被破坏的应用程序内存（例如，如果内存内容没有被修改，可以重新从磁盘读取数据）。但总会有程序状态被破坏，无法安全的继续运行程序的情况。在大多数 UNIX 系统中，受影响的程序在这种情况下被杀死，UNIX 信号 SIGBUS 最常在此时被使用。</p><p><img src="https://s2.loli.net/2022/08/16/xUQEf5bjG1oSXyK.png" alt="MCA 处理流程"></p><p>PM 的错误处理初看起来和内存相似，以在 Intel 架构上运行的 Linux 为例，内存错误是通过英特尔的 Machine Check Architecture（MCA）来报告的。当操作系统启用这一功能时，上图中的红色实心箭头显示了不可纠正错误的处理流程，当发生错误的位置被访问时，mcheck 模块会收到通知。</p><p>如之前所述，这时向应用程序发送 SIGBUS 信号可以让应用程序决定该做什么，然而由于这片区域是持久内存文件系统某个文件的一部分，即便应用程序会收到信号阻止它使用损坏的数据，也必须提供一个从这种情况中恢复的方法。系统管理员可能会尝试在更换有问题的 PM 之前备份文件系统中的其他数据，但是在我们目前所述的错误机制下，备份程序每次接触到损坏的位置都会收到一个 SIGBUS。在这种情况下，PM 感知的文件系统需要一种机制来接收错误通知，以便它能够隔离受影响的区域，继续提供对 PM 文件系统其余部分的访问。上图中的虚线箭头表示了这种机制，在启动时，文件系统告诉 mcheck 模块哪些 PM 地址范围是自己负责的，之后当错误发生时，文件系统会被 mcheck 模块调用来获得处理这个错误的机会。<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p><p>持久内存层的引入为应用程序开发人员提供了放置数据和数据结构的位置的新选择。传统上，数据被读取和写入易失性内存，然后刷新到非易失性持久存储。当应用程序启动时，必须先将数据从存储器中读取到易失性存储器中，然后才能对其进行访问。根据工作数据集的大小，这可能需要几秒钟、几分钟或几小时。通过巧妙的应用程序设计，开发人员和应用程序架构师现在可以利用这项新技术来提高性能并减少应用程序启动时间。持久内存引入了一些新的编程问题，这些问题不适用于传统的易失性内存。包括：数据持久性：在刷新之前，不能保证存储是持久的。尽管这对于已有数十年历史的内存映射文件 API（如 Linux 上的 mmap() 和 msync()）也是如此，但许多程序员还没有处理需要刷新到内存持久性的问题。遵循标准 API（如 msync() 刷新对持久性的更改）能够按预期工作。但是更优化的刷新使得应用程序直接从 CPU 缓存中刷新存储，而不是调用内核，也是可能的。<br>CPU 具有无序的 CPU 执行和缓存访问/刷新。这意味着如果应用程序存储了两个值，它们持久化的顺序可能不是应用程序写入它们的顺序。数据一致性：<br>8 字节存储在 x86 架构上是电源故障原子性的——如果在向对齐的 8 字节存储到 PMEM 期间发生电源故障，则在重新启动后该位置或者上旧的 8 字节或者是新的 8 字节（而不是两者的结合）。<br>x86 上大于 8 字节的任何内容都不是 powerfail atomic 的，因此需要由软件来实现一致性所需的任何事务/日志记录/恢复。请注意，这是特定于 x86 的——其他硬件平台可能具有不同的原子性大小（PMDK 的设计目的是让使用它的应用程序不必担心这些细节）。内存泄漏：持久存储的内存泄漏是持久的。重新启动服务器不会更改设备上的内容。在当前的 volatile 模型中，如果应用程序泄漏内存，重新启动应用程序或系统会释放该内存。字节级访问：应用开发者可以根据应用需求进行字节级别的读写。读/写不再需要对齐或等于存储块边界，例如：512byte、4KiB 或 8KiB。存储不需要读取整个块来修改几个字节，然后将整个块写回持久存储。应用程序可以根据需要随意读/写。这提高了性能并减少了内存占用开销。错误处理：应用程序可能需要直接检测和处理硬件错误。由于应用程序可以直接访问持久内存介质，因此任何错误都将作为内存错误返回给应用程序。</p><h3 id="pmem" tabindex="-1" id="PMEM">PMEM</h3><h4 id="dax" tabindex="-1" id="DAX">DAX</h4><h4 id="btt" tabindex="-1" id="BTT">BTT</h4><h3 id="%E5%AE%9E%E7%8E%B0" tabindex="-1" id="实现">实现</h3><p>Linux 上关于持久内存的配置概念方面曾经有过一些变动，本章节将以本文撰写时最新内核和工具的支持情况为基础。</p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://www.usenix.org/system/files/login/articles/08_rudoff_040-045_final.pdf">Programming Models for Emerging Non-Volatile Memory Technologies</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    
    <summary type="html">&lt;p&gt;nvdimm，即非易失性双列直插式内存模块（non-volatile DIMM），相对于传统的易失性内存，nvdimm 在断电后其中的内容也不会消失。&lt;/p&gt;</summary>
    
    
    
    <category term="硬件" scheme="https://universesaurora.top/categories/%E7%A1%AC%E4%BB%B6/"/>
    
    
    <category term="硬件" scheme="https://universesaurora.top/tags/%E7%A1%AC%E4%BB%B6/"/>
    
    <category term="nvdimm" scheme="https://universesaurora.top/tags/nvdimm/"/>
    
  </entry>
  
  <entry>
    <title>小探 GI global-metadata</title>
    <link href="https://universesaurora.top/2022/06/10/gi_research_metadata/"/>
    <id>https://universesaurora.top/2022/06/10/gi_research_metadata/</id>
    <published>2022-06-10T12:07:34.000Z</published>
    <updated>2022-07-18T08:42:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>算是博客的第一篇正式文章。</p><p>最近尝试了一下原神私服，在弄模型替换的时候出了点问题，正好借此机会对游戏做一点探索。</p><article class="message message-immersive is-warning"><div class="message-body"><i class="fas fa-exclamation-triangle mr-2"></i>由于距本文撰写时已过去较长时间，最新版本的游戏保护方式已经升级，且这篇文章主要是我自己鼓捣的记录，因此应该没有什么价值了。</div></article><span id="more"></span><h2 id="%E8%B5%B7%E5%9B%A0" tabindex="-1" id="起因">起因</h2><p>想要在游戏中进行模型替换需要一个叫做 Melonloader 的框架，但这个框架在 2.7 版本中无法使用了<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>。查看产生的 log 可以发现该问题出在 Il2CppDumper 上：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">[20:57:40.389] Executing Il2CppDumper...</span><br><span class="line">[20:57:40.392] &quot;C:\Users\Miguel\Downloads\GrassCutPer\Genshin Impact\Genshin Impact Game\MelonLoader\Dependencies\Il2CppAssemblyGenerator\Il2CppDumper\Il2CppDumper.exe&quot; &quot;C:\Users\Miguel\Downloads\GrassCutPer\Genshin Impact\Genshin Impact Game\YuanShen_Data\Native\UserAssembly.dll&quot; &quot;C:\Users\Miguel\Downloads\GrassCutPer\Genshin Impact\Genshin Impact Game\YuanShen_Data\Native\Data\Metadata\global-metadata.dat&quot;</span><br><span class="line">[20:57:40.766] Initializing metadata...</span><br><span class="line">[20:57:46.401] System.InvalidOperationException: 序列不包含任何元素</span><br><span class="line">[20:57:46.401]    在 System.Linq.Enumerable.Max[TSource](IEnumerable`1 source)</span><br><span class="line">[20:57:46.402]    在 Il2CppDumper.Metadata.&lt;&gt;c.&lt;ProcessingMetadataUsage&gt;b__38_0(KeyValuePair`2 x)</span><br><span class="line">[20:57:46.403]    在 System.Linq.Enumerable.WhereSelectEnumerableIterator`2.MoveNext()</span><br><span class="line">[20:57:46.404]    在 System.Linq.Enumerable.Max[TSource](IEnumerable`1 source)</span><br><span class="line">[20:57:46.405]    在 Il2CppDumper.Metadata.ProcessingMetadataUsage()</span><br><span class="line">[20:57:46.406]    在 Il2CppDumper.Metadata..ctor(Stream stream, StringDecryptionData decData, String nameTranslationPath)</span><br><span class="line">[20:57:46.407]    在 Il2CppDumper.Program.Init(String il2cppPath, String metadataPath, String nameTranslationPath, Metadata&amp; metadata, Il2Cpp&amp; il2Cpp)</span><br><span class="line">[20:57:46.408]    在 Il2CppDumper.Program.Main(String[] args)</span><br><span class="line">[20:57:46.419] Executing Il2CppAssemblyUnhollower...</span><br><span class="line">...</span><br><span class="line">[20:57:46.516] [ERROR] 未经处理的异常:  System.IO.DirectoryNotFoundException: 未能找到路径“C:\Users\Miguel\Downloads\GrassCutPer\Genshin Impact\Genshin Impact Game\MelonLoader\Dependencies\Il2CppAssemblyGenerator\Il2CppDumper\DummyDll”的一部分。</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>经过一番搜索后，我发现这个 Il2CppDumper 实际上是被修改过的，原本的 Il2CppDumper 只能解析出 unity 正常生成的 global-metadata.dat，但游戏将 global-metadata.dat 文件进行了一些混淆，所以不将其解密是无法成功将元数据导出来的。Il2CppDumper 大概的作用就是把经过 Il2Cpp 转换后需要用到的符号还原出来并生成一系列 dll 文件，而 Melonloader 的运行应该需要用到这些 dll 文件。</p><p>这样看来应该是 2.7 版本的混淆方法有了变化，导致这个针对之前设计的 Il2CppDumper 没法正确解密了。虽然静等作者更新这个程序也不是不行，但刚好我之前有过探索下这个游戏背后的程序结构之类的想法，于是就打算自己分析分析看看能不能把这个解密方法修复下。</p><h2 id="%E8%A1%8C%E4%B8%BA" tabindex="-1" id="行为">行为</h2><p>用二进制编辑器看了下 metadata 文件，头部的标志已经没有了，和之前版本的对比了下也没看出来什么门道。我首先想到的是抓抓系统调用看看打开 metadata 文件的前后发生了些啥，然而抓了后又把 map/read 之类操作和 metadata 文件对了下，依然看不出什么东西，显然这种简单的分析是完全没用的。更诡异的是运行几次后连 read 都抓不到了，难不成这东西还有缓存的？</p><p><img src="https://s2.loli.net/2022/06/10/VgBNwJjQX9mWU82.png" alt="Process Monitor 记录"></p><h2 id="%E5%88%86%E6%9E%90-userassembly.dll" tabindex="-1" id="分析-UserAssembly-dll">分析 UserAssembly.dll</h2><p>于是把 UserAssembly.dll 丢进 ida 分析了下。直接搜索字符串 global-metadata，找到了看起来可能是打开文件的地方：</p><p><img src="https://s2.loli.net/2022/06/10/ZbP5GaLAdsYv2D9.png" alt="疑似打开文件"></p><p>于是我参考了网上相关文章研究了下，怀疑到下面有一处调用的解密函数，这个函数初始化在一个导出函数中，其中还初始化了另一个函数。</p><p><img src="https://s2.loli.net/2022/06/10/E4GAKo6kPxJReO8.png" alt="初始化解密函数"></p><p>不过解密函数目前来看都不在这个 dll 中，四处翻了翻后我就暂时结束了对 UserAssembly.dll 的探索。</p><h2 id="%E5%88%86%E6%9E%90-il2cppdumper" tabindex="-1" id="分析-Il2CppDumper">分析 Il2CppDumper</h2><p>接下来我把目光转向了 Il2CppDumper，想通过它分析下之前版本的 metadata 是怎么解密出来的（没找到这个被修改过的 Il2CppDumper 源码）（更新：其实是有源码的，在另一个<a href="https://github.com/Three-taile-dragon/MelonLoader-GenshinImpact">仓库</a>）。于是把他丢进 ida，搜索打印的 log 字符串 “Initializing metadata…”，很快我就发现了一个叫做 DecryptMetadata 的函数，显然是解密函数：</p><p><img src="https://s2.loli.net/2022/06/10/SQeip7WVCR6atUl.png" alt="DecryptMetadata"></p><p>ida 好像反汇编不了 .net 的程序，换个反编译工具 dnSpy，这下源码基本完全解析出来了。首先动态调试了下，找到异常抛出的位置向前回溯，发现问题出自 header.metadataUsageListsCount 为 0，这个 header 又是通过之前解密的 metadata 数据初始化出来的，这样看 metadata 果然还是没有被正确解密。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> MetadataDecryption.<span class="function">StringDecryptionData <span class="title">DecryptMetadata</span>(<span class="params"><span class="built_in">byte</span>[] metadata</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">MetadataDecryption.DecryptMetadataBlocks(metadata);</span><br><span class="line"><span class="keyword">return</span> MetadataDecryption.DecryptMetadataStringInfo(metadata);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>细看第一个解密函数 DecryptMetadataBlocks，先是从文件后部复制了点数据，之后做了个比较。奇怪的是这个比较通过了，我又在二进制编辑器里对了下这个值，确实是对的，看来加密逻辑没有变动太多？</p><figure class="highlight csharp"><figcaption><span>第一个解密函数</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DecryptMetadataBlocks</span>(<span class="params"><span class="built_in">byte</span>[] metadata</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">byte</span>[] array = <span class="keyword">new</span> <span class="built_in">byte</span>[<span class="number">16384</span>];</span><br><span class="line">Buffer.BlockCopy(metadata, metadata.Length - array.Length, array, <span class="number">0</span>, array.Length);</span><br><span class="line"><span class="keyword">if</span> (array[<span class="number">200</span>] != <span class="number">46</span> || array[<span class="number">201</span>] != <span class="number">252</span> || array[<span class="number">202</span>] != <span class="number">254</span> || array[<span class="number">203</span>] != <span class="number">44</span>)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException(<span class="string">&quot;*((uint32_t*)&amp;footer[0xC8]) != 0x2CFEFC2E&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后面主要就是数据复制，用异或方法压缩出了一个 key，之后又异或了一堆奇怪的预定义的值。看来之前加密的逻辑主要还是异或，还用到了一些预先定义好的数据。到这里感觉从 Il2CppDumper 也不再能看出太多了。</p><h2 id="%E6%90%AD%E5%BB%BA%E4%B8%BB%E7%A8%8B%E5%BA%8F%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83" tabindex="-1" id="搭建主程序调试环境">搭建主程序调试环境</h2><p>推测下解密函数很有可能应该在主程序 YuanShen.exe 里面了，研究了下找到个方法能通过调试器直接启动游戏本体进私服，方便之后调试。（更新：其实只要用的是 Fiddler 这种抓包软件就行了，效果一样且更方便）</p><p>修改 GrassClipper 的 scripts/private_server_launch.cmd，找到这里：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:: Launch game</span><br><span class="line">&quot;<span class="variable">%GAME_PATH%</span>&quot;</span><br></pre></td></tr></table></figure><p>把 <code>&quot;%GAME_PATH%&quot;</code> 这部分注释掉，加个 pause。之后启动先把 grasscutter 服务端跑起来，然后在命令行运行这个脚本，带上下面这些参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private_server_launch.cmd 127.0.0.1 443 <span class="literal">true</span> <span class="string">&quot;&lt;YuanShen.exe 路径&gt;&quot;</span> <span class="string">&quot;&lt;GrassClipper 路径&gt;&quot;</span> <span class="literal">false</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>这里服务地址端口都是默认的配置，之后这个脚本会把代理开起来，接下来直接运行游戏本体就能进私服了，关闭记得在终端输入字符把剩下的关闭流程跑完，否则代理设置不会被清除掉没法正常联网。</p><p>搭好调试环境后，我发现这游戏主程序加了壳的没法直接调试（废话），想在游戏过程中挂 x64dbg 也挂不上，不知道用了什么魔法。另外游戏会不断检查并尝试杀掉 x64dbg 等调试器，启动时也会检查，以及如果杀不掉甚至游戏直接退出。所以这个部分遇到了点困难。</p><p><img src="https://s2.loli.net/2022/06/10/JWm9QEqiTSVgLX3.png" alt="本体有 vmp 壳"></p><h2 id="%E5%B0%9D%E8%AF%95%E6%96%B0%E7%9A%84-il2cppdumper" tabindex="-1" id="尝试新的-Il2CppDumper">尝试新的 Il2CppDumper</h2><p>回来更新文章了，发现已经有人更新了针对 2.7+ 版本的 Il2CppDumper<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>，所以尝试直接用它替换掉原本的 Il2CppDumper。</p><p>运行后 Il2CppDumper 成功生成了 DummyDll，但是还是有其他错误，下面是比较关键的部分：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">[01:25:26.036] ------------------------------</span><br><span class="line">[01:25:26.037] Game Name: 原神</span><br><span class="line">[01:25:26.037] Game Developer: miHoYo</span><br><span class="line">[01:25:26.038] Unity Version: 2017.4.30f1</span><br><span class="line">[01:25:26.038] Game Version:</span><br><span class="line">[01:25:26.039] ------------------------------</span><br><span class="line">[01:25:26.379] Preferences Loaded!</span><br><span class="line">[01:25:26.398] [Il2CppUnityTls] Patching mono_unity_get_unitytls_interface...</span><br><span class="line">[01:25:26.401] Loading Plugins...</span><br><span class="line"></span><br><span class="line">[01:25:26.409] ------------------------------</span><br><span class="line">[01:25:26.409] No Plugins Loaded!</span><br><span class="line">[01:25:26.410] ------------------------------</span><br><span class="line">[libil2cpp] Failed to resolve 3441514353 at startup</span><br><span class="line">[libil2cpp] Failed to resolve 2641773275 at startup</span><br><span class="line">[libil2cpp] Failed to resolve 3753878500 at startup</span><br><span class="line">[libil2cpp] Failed to resolve 1688788800 at startup</span><br><span class="line">[libil2cpp] Failed to resolve 226400704 at startup</span><br><span class="line">[libil2cpp] Failed to resolve 58785463 at startup</span><br><span class="line">[libil2cpp] Failed to resolve 1939797683 at startup</span><br><span class="line">[libil2cpp] Failed to resolve 2903149294 at startup</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">[00:50:23.258] &quot;C:\Users\Miguel\Downloads\gi-priv\games\gi_2.7.0_self\Genshin Impact Game\MelonLoader\Dependencies\Il2CppAssemblyGenerator\Il2CppAssemblyUnhollower\AssemblyUnhollower.exe&quot; &quot;--input=C:\Users\Miguel\Downloads\gi-priv\games\gi_2.7.0_self\Genshin Impact Game\MelonLoader\Dependencies\Il2CppAssemblyGenerator\Il2CppDumper\DummyDll&quot; &quot;--output=C:\Users\Miguel\Downloads\gi-priv\games\gi_2.7.0_self\Genshin Impact Game\MelonLoader\Dependencies\Il2CppAssemblyGenerator\Il2CppAssemblyUnhollower\Managed&quot; &quot;--mscorlib=C:\Users\Miguel\Downloads\gi-priv\games\gi_2.7.0_self\Genshin Impact Game\MelonLoader\Managed\mscorlib.dll&quot; &quot;--unity=C:\Users\Miguel\Downloads\gi-priv\games\gi_2.7.0_self\Genshin Impact Game\MelonLoader\Dependencies\Il2CppAssemblyGenerator\UnityDependencies&quot; &quot;--gameassembly=C:\Users\Miguel\Downloads\gi-priv\games\gi_2.7.0_self\Genshin Impact Game\YuanShen_Data\Native\UserAssembly.dll&quot; &quot;--add-prefix-to=ICSharpCode&quot; &quot;--add-prefix-to=Newtonsoft&quot; &quot;--add-prefix-to=TinyJson&quot; &quot;--add-prefix-to=Valve.Newtonsoft&quot; &quot;--no-xref-cache&quot;</span><br><span class="line">[00:50:23.348] Reading assemblies... </span><br><span class="line">[00:50:23.538] Done in 00:00:00.1889345</span><br><span class="line">[00:50:23.539] Reading system assemblies... </span><br><span class="line">[00:50:23.552] Done in 00:00:00.0138266</span><br><span class="line">[00:50:23.553] Reading unity assemblies... </span><br><span class="line">[00:50:23.563] Done in 00:00:00.0100095</span><br><span class="line">[00:50:23.564] Creating rewrite assemblies... </span><br><span class="line">[00:50:23.584] Done in 00:00:00.0218627</span><br><span class="line">[00:50:23.585] Computing renames... </span><br><span class="line">[00:50:23.616] [ERROR] </span><br><span class="line">[00:50:23.657] [ERROR] 未经处理的异常:  Mono.Cecil.AssemblyResolutionException: Failed to resolve assembly: &#x27;System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e&#x27;</span><br><span class="line">[00:50:23.658] [ERROR]    在 Mono.Cecil.BaseAssemblyResolver.Resolve(AssemblyNameReference name, ReaderParameters parameters)</span><br><span class="line">[00:50:23.659] [ERROR]    在 Mono.Cecil.DefaultAssemblyResolver.Resolve(AssemblyNameReference name)</span><br><span class="line">[00:50:23.659] [ERROR]    在 Mono.Cecil.MetadataResolver.Resolve(TypeReference type)</span><br><span class="line">[00:50:23.660] [ERROR]    在 Mono.Cecil.TypeReference.Resolve()</span><br><span class="line">[00:50:23.661] [ERROR]    在 AssemblyUnhollower.Passes.Pass05CreateRenameGroups.NameOrRename(TypeReference typeRef, RewriteGlobalContext context)</span><br><span class="line">[00:50:23.662] [ERROR]    在 AssemblyUnhollower.Passes.Pass05CreateRenameGroups.GenericNameToStrings(TypeReference typeRef, RewriteGlobalContext context)</span><br><span class="line">[00:50:23.663] [ERROR]    在 AssemblyUnhollower.Passes.Pass05CreateRenameGroups.GetUnobfuscatedNameBase(RewriteGlobalContext context, TypeDefinition typeDefinition, Boolean allowExtraHeuristics)</span><br><span class="line">[00:50:23.664] [ERROR]    在 AssemblyUnhollower.Passes.Pass05CreateRenameGroups.ProcessType(RewriteGlobalContext context, TypeDefinition originalType, Boolean allowExtraHeuristics)</span><br><span class="line">[00:50:23.665] [ERROR]    在 AssemblyUnhollower.Passes.Pass05CreateRenameGroups.ProcessType(RewriteGlobalContext context, TypeDefinition originalType, Boolean allowExtraHeuristics)</span><br><span class="line">[00:50:23.665] [ERROR]    在 AssemblyUnhollower.Passes.Pass05CreateRenameGroups.DoPass(RewriteGlobalContext context)</span><br><span class="line">[00:50:23.666] [ERROR]    在 AssemblyUnhollower.Program.Main(UnhollowerOptions options)</span><br><span class="line">[00:50:23.667] [ERROR]    在 AssemblyUnhollower.Program.Main(String[] args)</span><br><span class="line">[00:50:25.289] Done in 00:00:01.7042110</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[00:50:25.370] Loading Mods...</span><br><span class="line">[00:50:25.389] [ERROR] No MelonInfoAttribute Found in C:\Users\Miguel\Downloads\gi-priv\games\gi_2.7.0_self\Genshin Impact Game\Mods\ClassLibrary3.dll</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">[00:50:25.499] [ERROR] Field internalEncoding was not found on class StreamWriter</span><br><span class="line">[00:50:25.500] [ERROR] Field internalStream was not found on class StreamWriter</span><br><span class="line">[00:50:25.502] [ERROR] Field iflush was not found on class StreamWriter</span><br><span class="line">[00:50:25.503] [ERROR] Field byte_buf was not found on class StreamWriter</span><br><span class="line">[00:50:25.504] [ERROR] Field byte_pos was not found on class StreamWriter</span><br><span class="line">[00:50:25.504] [ERROR] Field decode_buf was not found on class StreamWriter</span><br><span class="line">[00:50:25.505] [ERROR] Field decode_pos was not found on class StreamWriter</span><br><span class="line">[00:50:25.506] [ERROR] Field DisposedAlready was not found on class StreamWriter</span><br><span class="line">[00:50:25.506] [ERROR] Field preamble_done was not found on class StreamWriter</span><br><span class="line">[00:50:25.507] [ERROR] Field internalFormatProvider was not found on class TextWriter</span><br></pre></td></tr></table></figure><p>这里放的 log 比较多，大部分内容在之前的 log 中也是有的，不同的部分在于 Il2CppDumper 生成 DummyDll 后接着又运行的 Il2CppAssemblyUnhollower 给出的错误。</p><p>从 trace 来看 AssemblyUnhollower 又用到了 Mono.Cecil 这个库，在该库中抛出了一个异常。除此之外开头部分的 libil2cpp 也还不清楚是谁打印的，这部分错误从一开始就存在，且没有被写入 log 文件中，可能比较特殊。</p><p>于是我又从网上找了一个 <a href="https://gh.fakev.cn/RoflanProgers/Il2CppAssemblyUnhollower-GenshinImpact">Il2CppAssemblyUnhollower 源码</a>，这个原仓库应该是没了，链接的是镜像站。抱着试一试的心态编译了一下，发现并没有出现类似报错，不过出现了 methods failed to restore 的情况，不知道是否正常。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">Reading assemblies...</span><br><span class="line">Done in 00:00:00.2249948</span><br><span class="line">Reading system assemblies...</span><br><span class="line">Done in 00:00:00.0138076</span><br><span class="line">Reading unity assemblies...</span><br><span class="line">Done in 00:00:00.0249082</span><br><span class="line">Creating rewrite assemblies...</span><br><span class="line">Done in 00:00:00.0095615</span><br><span class="line">Computing renames...</span><br><span class="line">Done in 00:00:00.0759375</span><br><span class="line">Creating typedefs...</span><br><span class="line">Done in 00:00:00.3707064</span><br><span class="line">Computing struct blittability...</span><br><span class="line">Done in 00:00:00.0270083</span><br><span class="line">Filling typedefs...</span><br><span class="line">Done in 00:00:00.0354803</span><br><span class="line">Filling generic constraints...</span><br><span class="line">Done in 00:00:00.0068350</span><br><span class="line">Creating members...</span><br><span class="line">Done in 00:00:04.5136379</span><br><span class="line">Scanning method cross-references...</span><br><span class="line">Done in 00:00:01.7303552</span><br><span class="line">Finalizing method declarations...</span><br><span class="line">Done in 00:00:10.2081680</span><br><span class="line">0 total potentially dead methods</span><br><span class="line">Filling method parameters...</span><br><span class="line">Done in 00:00:00.7021279</span><br><span class="line">Creating static constructors...</span><br><span class="line">Done in 00:00:02.1416967</span><br><span class="line">Creating value type fields...</span><br><span class="line">Done in 00:00:00.1698024</span><br><span class="line">Creating enums...</span><br><span class="line">Done in 00:00:00.0984626</span><br><span class="line">Creating IntPtr constructors...</span><br><span class="line">Done in 00:00:00.1559927</span><br><span class="line">Creating type getters...</span><br><span class="line">Done in 00:00:00.2090254</span><br><span class="line">Creating non-blittable struct constructors...</span><br><span class="line">Done in 00:00:00.0172973</span><br><span class="line">Creating generic method static constructors...</span><br><span class="line">Done in 00:00:00.0622003</span><br><span class="line">Creating field accessors...</span><br><span class="line">Done in 00:00:03.4009610</span><br><span class="line">Filling methods...</span><br><span class="line">Done in 00:00:03.5433611</span><br><span class="line">Generating implicit conversions...</span><br><span class="line">Done in 00:00:00.0293020</span><br><span class="line">Creating properties...</span><br><span class="line">Done in 00:00:00.2467474</span><br><span class="line">Unstripping types...</span><br><span class="line">Done in 00:00:00.0325269</span><br><span class="line">Unstripping fields...</span><br><span class="line"></span><br><span class="line">286 fields restored</span><br><span class="line">7 fields failed to restore</span><br><span class="line">Done in 00:00:00.0090604</span><br><span class="line">Unstripping methods...</span><br><span class="line"></span><br><span class="line">7760 methods restored</span><br><span class="line">213 methods failed to restore</span><br><span class="line">Done in 00:00:00.3213333</span><br><span class="line">Unstripping method bodies...</span><br><span class="line"></span><br><span class="line">IL unstrip statistics: 3567 successful, 594 failed</span><br><span class="line">Done in 00:00:00.1510770</span><br><span class="line">Generating forwarded types...</span><br><span class="line">Done in 00:00:00.0416483</span><br><span class="line">Writing xref cache...</span><br><span class="line">Done in 00:00:00.0073933</span><br><span class="line">Writing assemblies...</span><br><span class="line">Done in 00:00:10.7976969</span><br><span class="line">Writing method pointer map...</span><br><span class="line">Done in 00:00:00.1345476</span><br><span class="line">Done!</span><br></pre></td></tr></table></figure><p>赶紧放到 MelonLoader 里试一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[14:07:32.626] ------------------------------</span><br><span class="line">[14:07:32.627] 4 Mods Loaded</span><br><span class="line">[14:07:32.627] ------------------------------</span><br><span class="line">[14:07:32.628] Camera Tools v1.0.6</span><br><span class="line">[14:07:32.628] by portra</span><br><span class="line">[14:07:32.631] SHA256 Hash: 12464c1f24f4267a3f75afc6a26f2148b7b0fd6a7d2c9607f8dac0c91d20ac50</span><br><span class="line">[14:07:32.631] ------------------------------</span><br><span class="line">[14:07:32.632] HideUIScript v1.0.0</span><br><span class="line">[14:07:32.632] by Taiga74164</span><br><span class="line">[14:07:32.633] SHA256 Hash: 2b272e95f1062d01800c4da58f7dee800aeb8726a47ec2da02507bfa82c31640</span><br><span class="line">[14:07:32.634] ------------------------------</span><br><span class="line">[14:07:32.634] Model Changer v0.0.8</span><br><span class="line">[14:07:32.635] by portra</span><br><span class="line">[14:07:32.638] SHA256 Hash: dd7c505195b0ea8151945b7e1dc66a1583fa9488c6175808da6957fbe20ecde1</span><br><span class="line">[14:07:32.638] ------------------------------</span><br><span class="line">[14:07:32.638] UnityExplorer v4.9.0</span><br><span class="line">[14:07:32.639] by Sinai</span><br><span class="line">[14:07:32.663] SHA256 Hash: 09f49edd0be7c2c1aecbb892e360230094fd172acac51dce8f75557f3873946a</span><br><span class="line">[14:07:32.664] ------------------------------</span><br><span class="line">[14:07:32.668] [ERROR] No Support Module Loaded!</span><br></pre></td></tr></table></figure><p>游戏成功启动，但是 UnityExplorer 并没有加载，log 如上，之前的错误中除了 libil2cpp 的报错都已经消失了。</p><p>看这个错误是 mod 不受支持，在 MelonLoader 源码中找到了该打印的来源：</p><figure class="highlight csharp"><figcaption><span>MelonLoader\SupportModule\SupportModule.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Interface == <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">MelonLogger.Error(<span class="string">&quot;No Support Module Loaded!&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在里面加了一些打印：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[15:12:28.210] [ERROR] Found: System.Collections.Generic.List`1[MelonLoader.SupportModule+ModuleListing]</span><br><span class="line">[15:12:28.210] [ERROR] Found: C:\Users\Miguel\Downloads\gi-priv\games\gi_2.7.0_self\Genshin Impact Game\MelonLoader\Dependencies\SupportModules\Il2Cpp.dll</span><br><span class="line">[15:12:28.211] [ERROR] Loading: C:\Users\Miguel\Downloads\gi-priv\games\gi_2.7.0_self\Genshin Impact Game\MelonLoader\Dependencies\SupportModules\Il2Cpp.dll</span><br><span class="line">[15:12:28.213] [ERROR] Support Module [Il2Cpp.dll] threw an Exception: System.Reflection.TargetInvocationException: Exception has been thrown by the target of an invocation. ---&gt; System.IO.FileNotFoundException: Could not load file or assembly &#x27;netstandard, Version=2.1.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51&#x27; or one of its dependencies.</span><br><span class="line">  at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&amp;)</span><br><span class="line">  at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x00032] in &lt;e1319b7195c343e79b385cd3aa43f5dc&gt;:0</span><br><span class="line">   --- End of inner exception stack trace ---</span><br><span class="line">  at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x00048] in &lt;e1319b7195c343e79b385cd3aa43f5dc&gt;:0</span><br><span class="line">  at System.Reflection.MethodBase.Invoke (System.Object obj, System.Object[] parameters) [0x00000] in &lt;e1319b7195c343e79b385cd3aa43f5dc&gt;:0</span><br><span class="line">  at MelonLoader.SupportModule.LoadInterface (System.String ModulePath) [0x00063] in &lt;20bb3b548fca4badbe0683004df1b626&gt;:0</span><br><span class="line">  at MelonLoader.SupportModule.Setup () [0x000c3] in &lt;20bb3b548fca4badbe0683004df1b626&gt;:0</span><br><span class="line">[15:12:28.214] [ERROR] Found: C:\Users\Miguel\Downloads\gi-priv\games\gi_2.7.0_self\Genshin Impact Game\MelonLoader\Dependencies\SupportModules\Mono.dll</span><br><span class="line">[15:12:28.217] [ERROR] No Support Module Loaded!</span><br></pre></td></tr></table></figure><p>看起来是和 Il2Cpp.dll 有关。</p><h2 id="%E5%85%B3%E4%BA%8E%E5%8F%8D%E8%B0%83%E8%AF%95" tabindex="-1" id="关于反调试">关于反调试</h2><p>之前稍微试着用 x64dbg 调试了下，感觉它应该是通过 mhypbase.dll 这个东西实现反调试的，由他加载 mhyprot2.Sys 和 mhyprot3.Sys 这两个驱动。用 ScyllaHide 的默认配置似乎会导致程序跳到0地址。这方面经验不多就不写了。</p><p>更新：由于有其他事情很长时间没有再研究这个问题，之后应该不会更新这篇文章了。如果有新进展会另开一篇。</p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://github.com/lassedds/Melonloader-AnimeGaming/issues/3">该问题的 Github Issue</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p><a href="https://github.com/1582421598/Il2CppDumper-Genshin">2.7+ 版本的 Il2CppDumper</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    
    <summary type="html">&lt;p&gt;算是博客的第一篇正式文章。&lt;/p&gt;
&lt;p&gt;最近尝试了一下原神私服，在弄模型替换的时候出了点问题，正好借此机会对游戏做一点探索。&lt;/p&gt;
&lt;article class=&quot;message message-immersive is-warning&quot;&gt;
&lt;div class=&quot;message-body&quot;&gt;
&lt;i class=&quot;fas fa-exclamation-triangle mr-2&quot;&gt;&lt;/i&gt;
由于距本文撰写时已过去较长时间，最新版本的游戏保护方式已经升级，且这篇文章主要是我自己鼓捣的记录，因此应该没有什么价值了。
&lt;/div&gt;
&lt;/article&gt;</summary>
    
    
    
    <category term="逆向" scheme="https://universesaurora.top/categories/%E9%80%86%E5%90%91/"/>
    
    
    <category term="逆向" scheme="https://universesaurora.top/tags/%E9%80%86%E5%90%91/"/>
    
    <category term="游戏" scheme="https://universesaurora.top/tags/%E6%B8%B8%E6%88%8F/"/>
    
  </entry>
  
  <entry>
    <title>序</title>
    <link href="https://universesaurora.top/2022/05/28/preface/"/>
    <id>https://universesaurora.top/2022/05/28/preface/</id>
    <published>2022-05-28T16:05:54.000Z</published>
    <updated>2022-05-29T03:22:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>总之是本博客的第一篇文章。</p><span id="more"></span><p>大概是我建的第三个博客了，之前的几个因为各种原因现在连记录都已经没有了。第一个博客是大概 18 年 5 月，我在自己的主机上用 Wordpress 搭建的。和现在这个不同，当时用的是 .com 域名。但是之前实际上也没写什么东西出来，唯一一个比较可惜的是写过一篇关于 Windows 驱动的文章，现在也没有备份了。</p><p>之所以又建了这个博客是因为最近又觉得自己应该有一个能写些东西的地方，在已有的平台上写总感觉有些拘束，不如自己建一个更自由些。</p><p>这个博客是用 <a href="https://hexo.io/zh-cn/">Hexo</a> 搭建的，托管在 <a href="https://github.com/UniversesAurora/universesaurora-blog">github</a> 上，相对方便一些。</p><p>之后应该不会再把博客删掉了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;总之是本博客的第一篇文章。&lt;/p&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://universesaurora.top/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="随笔" scheme="https://universesaurora.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
